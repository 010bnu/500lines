A Python interpreter written in Python

[ What: A Python interpreter ]
[ Why: interpreters ]
[ How: stack machines ]

Byterun is a Python interpreter written in Python.

The word "interpreter" is used in a variety of different ways when discussing Python, so first we will disambiguate what it means in this context. Sometimes "interpreter" refers to the Python REPL, the interactive prompt you get by typing just "python" from the command line. Sometimes people use "the Python interpreter" more or less interchangeably with "Python" to talk about executing Python code from start to finish. In this chapter, "interpreter" has a more narrow meaning: it's the last step in the process of running a Python program.

Before the interpreter takes over, Python performs three other steps: lexing, parsing, and compiling. Together, they turn the programmer's source code from lines of text into structured _code objects_ that the interpreter knows how to understand. Each code object contains a set of instructions that the interpreter will execute, plus other information necessary to execute those instructions. The interpreter's job is to take these code objects and perform the operations detailed there.

You may be surprised to hear that Python code is compiled. Python is often called an "interpreted" language, like Ruby or Java, in contrast with a "compiled" language like C or Rust. This terminology isn't as precise as it seems.  Most interpreted languages, including Python, do involve a compilation step. However, in an interpreted language, the compilation does relatively less work (and the interpreter does relatively more) than in a compiled language.  As we'll see later in the chapter, the Python compiler has much less information about the behavior of a program than a C compiler does.

### Bytecode
In Python, the set of instructions that the interpreter interprets is called _bytecode_. Bytecode is a series of bytes that the interpreter maps to different operations that it should perform. Bytecode is called an _intermediate representation_ of Python code: it expresses the source code that you wrote in a way the interpreter can understand, analogous to the way that assembly language serves as a representation between C code and a piece of hardware.

### A Python Python interpreter
Byterun is a Python interpreter written in Python.  This may strike you as odd, but it's no more odd than writing a C compiler in C. (Indeed, the widely-used C compiler gcc is written in C.) We could write a Python interpreter in almost any language.

Byterun's structure very closely mirrors the structure of the "real" interpreter in CPython, the most commonly used Python interpreter. In CPython, as the name would suggest, the interpreter is written in C. Understanding Byterun, via this chapter, will help you understand interpreters in general and the CPython interpreter in particular.

Executing code via Byterun is much slower than executing it in CPython. However, Byterun is much easier to understand. It is simplified relative to CPython: not all bytecodes are included, no optimizations for speed are present, and it's written in a higher-level language that many people find easier to read. Since our goal is understanding the system, not speed of execution, writing Byterun in Python is an easy decision.

## what about PyPy
There is a efficient Python interpreter written mostly in Python, called PyPy. PyPy's structure is signficantly different from CPython's structure, and it includes many interesting optimizations. I encourage curious readers to also read the chapter about PyPy from the second edition of this book.




### The structure of Byterun: A virtual machine
With that background, let's begin examining the structure of Byterun. The Python interpreter is a virtual machine, meaning that it is software that emulates a physical computer. This particular virtual machine is a stack machine: it manipulates several stacks to perform its operations (as contrasted with a register machine, that writes and reads values from particular memory locations). In our interpreter, we'll implement a stack using a Python list.

To make this concrete, let's start with a very minimal interpreter. This interpreter can only add numbers, and it understands just three instructions.

- LOAD_VALUE
- ADD_TWO_VALUES
- PRINT_ANSWER

Since we're not concerned with the lexer, parser, and compiler in this chapter, it doesn't matter how these instructions were produced.  You can imagine writing `1 + 1` in Python syntax and having a compiler emit these three compiles down to these three instructions, properly arranged. You could write lisp syntax and have a compiler that generates the same three instructions. All that matters is that our interpreter has an arrangement of these three instructions in a way that makes sense to it. We'll now look at such a system.

When you call code that adds two numbers, the interpreter will begin by pushing the first number onto the stack, then pushing the second number onto the stack. Next it will pop both numbers off, add them together, and push the result onto the stack. Finally, it will pop the answer back off the stack and return it.

The steps before the interpreter (the lexer, parser, and compiler) take your code and turned it in to instructions for the interpreter. These instructions are similar to bytecode.

~~~~
1 + 2
~~~~
produces "bytecode" like this:

~~~~
["LOAD_VALUE",
 "LOAD_VALUE",
 "ADD_TWO_VALUES",
 "PRINT_ANSWER"]
~~~~

Before the interpreter can add numbers for you, it needs a little more information. The instructions tell it to push a number on to the stack, but they don't say which number. We'll add an extra piece of information to each instruction, telling the interpreter where to find the number if one is required. We'll also pass the numbers themselves to the interpreter. We'll wrap up these two pieces, the instructions and the numbers, into a dictionary. Here, the "instructions" piece is like Python bytecode, and the entire "what to execute" dictionary is like a code object.

~~~~
what_to_execute = {
    "instructions": [("LOAD_VALUE", 0),  # the first number
                     ("LOAD_VALUE", 1),  # the second number
                     ("ADD_TWO_VALUES", None),
                     ("PRINT_ANSWER", None)],
    "numbers": [7, 5] }
~~~~

Now let's look at the interpreter itself. The interpreter object has a stack, represented by a list. Each instruction is defined as a method on the object.

~~~~
class Interpreter(object):
    def __init__(self):
        self.stack = []

    def LOAD_VALUE(self, number):
        self.stack.append(number)

    def PRINT_ANSWER(self):
        answer = self.stack.pop()
        print(answer)

    def ADD_TWO_VALUES(self):
        first_num = self.stack.pop()
        second_num = self.stack.pop()
        total = first_num + second_num
        self.stack.append(total)
~~~~

The interpreter needs one more piece: a way to tie everything together and start executing. This method takes the "what_to_execute" dictionary defined above as an argument. It loops over each instruction, processes the arguments to that instruction if there are any, and then calls the corresponding method on the interpreter object.

~~~~.py
    def execute(self, what_to_execute):
        instructions = what_to_execute["instructions"]
        numbers = what_to_execute["numbers"]
        for each_step in instructions:
            instruction, argument = each_step
            if instruction == "LOAD_VALUE":
                number = numbers[argument]
                self.LOAD_VALUE(number)
            elif instruction == "ADD_TWO_VALUES":
                self.ADD_TWO_VALUES()
            elif instruction == "PRINT_ANSWER":
                self.PRINT_ANSWER()
~~~~

Let's test it out:

~~~~
    interpreter = Interpreter()
    interpreter.execute(what_to_execute)
~~~~

Sure enough, it prints the answer - 12.

Although this interpreter is quite limited, this process is almost exactly how the real Python interpreter adds numbers. There are a couple of things to notice from even this small example.  First of all, some instructions need arguments. In real Python bytecode, about half of instructions have arguments. The arguments are packed in with the instructions, much like in our example. Notice that the arguments to the _instructions_ are different than the arguments to the methods that are called. In the numbers example, the argument to the instruction was an index saying where to find the object. To see why, imagine if we were adding strings together instead of numbers. We wouldn't want to have the strings stuffed in with the instructions, since they could be arbitrarily large.

Second, notice that the instruction for adding together two values did not require any arguments. Instead, the values to be added together were popped off of the interpreter's stack. Given valid instruction sets, without any changes to our interpreter, we can add more than two numbers at at time. Try running the instruction set below. What do you expect to happen? If you had a friendly compiler, what code could you write to generate this instruction set?

~~~~
    what_to_execute = {
        "instructions": [("LOAD_VALUE", 0),
                         ("LOAD_VALUE", 1),
                         ("ADD_TWO_VALUES", None),
                         ("LOAD_VALUE", 2),
                         ("ADD_TWO_VALUES", None),
                         ("PRINT_ANSWER", None)],
        "numbers": [7, 5, 8] }
~~~~

So far our interpreter that can only do simple arithmetic. However, we can begin to see how this structure is extensible - we can add methods on the object that describe many more operations (as long as we have a compiler to hand us well-formed instruction sets).

# Variables
Adding variables to our interpreter requires three main pieces: two instructions for storing and retrieving the values, plus a dictionary mapping names to values, stored on the interpreter object.

~~~~
>>> def s():
...     a = 1
...     b = 2
...     return a + b
<< compiler works here >>
    what_to_execute = {
        "instructions": [("LOAD_VALUE", 0),
                         ("STORE_NAME", 0),
                         ("LOAD_VALUE", 1),
                         ("STORE_NAME", 1),
                         ("LOAD_NAME", 0),
                         ("LOAD_NAME", 1),
                         ("ADD_TWO_VALUES", None),
                         ("PRINT_ANSWER", None)],
        "numbers": [1, 2],
        "names":   ["a", "b"] }
~~~

The interpreter now needs to keep track of what names are bound to what values, so we'll add an "environment" dictionary to the __init__ method. We'll also add STORE_NAME and LOAD_NAME methods that are analogous to the STORE_VALUE and LOAD_VALUE methods we defined earlier.

The arguments to an instruction can now mean two different things. It can either be an index into the "numbers" list, or it can be an index into the "names" list. The interpreter knows which is should be by checking what the instruction should do. We'll break out this logic - and the mapping of instructions to what their arguments mean - into a separate method.

~~~~
    def __init__(self):
        self.stack = []
        self.environment = {}

    def STORE_NAME(self, name):
        val = self.stack.pop()
        print("storing name %s: %s" % (name, val))
        self.environment[name] = val

    def LOAD_NAME(self, name):
        val = self.environment[name]
        self.stack.append(val)

    def parse_argument(self, instruction, argument, what_to_execute):
        argument_meaning = {"numbers": ["LOAD_VALUE"],
                            "names": ["LOAD_NAME", "STORE_NAME"]}

        if instruction in argument_meaning["numbers"]:
            argument = what_to_execute["numbers"][argument]
        elif instruction in argument_meaning["names"]:
            argument = what_to_execute["names"][argument]

        return argument

    def execute(self, what_to_execute):
        instructions = what_to_execute["instructions"]
        for each_step in instructions:
            instruction, argument = each_step
            argument = self.parse_argument(instruction, argument, what_to_execute)

            if instruction == "LOAD_VALUE":
                self.LOAD_VALUE(argument)
            elif instruction == "ADD_TWO_VALUES":
                self.ADD_TWO_VALUES()
            elif instruction == "PRINT_ANSWER":
                self.PRINT_ANSWER()
            elif instruction == "STORE_NAME":
                self.STORE_NAME(argument)
            elif instruction == "LOAD_NAME":
                self.LOAD_NAME(argument)

# Conditionals



# Loops
# Functions
# Exceptions

There are three kinds of stacks that the Python interpreter uses.  The first is the _call stack_, made up of frames. A frame is a collection of information and context for a chunk of code, typically a single function call. Each frame has two more stacks associated with it: the data stack, which contains data and objects, and a block stack, used for certain kinds of (control flow such as exception handling and looping).  The primary work of the interpreter is manipulating these three kinds of stacks.

The interpreter needs to keep track of a few things beyond the call stack, like the exception state, the current frame, and the values to be passed between frames.

Information on the frame includes the the code object for the frame, the global and local namespaces, a reference to the calling frame, and the last bytecode instruction executed.

Let's make this concrete with an example. Suppose we have the following code, and the Python interpreter is currently executing the marked line.  Here's a schematic of the call stack of frames, the block stacks, and the data stacks.

```python main.py
def foo():
    x = 1
    def bar(y):
        z = y + 2  # <--- (3) ... and the interpreter is here.
        return z
    return bar(x)  # <--- (2) ... which is returning a call to bar ...
foo()              # <--- (1) We're in the middle of a call to foo ...
```

```
c   ---------------------
a  | bar Frame           | -> block stack: []
l  |     (newest)        | -> data stack: [1, 2]
l   ---------------------
   | foo Frame           | -> block stack: []
s  |                     | -> data stack: []
t   ---------------------
a  | main (module) Frame | -> block stack: []
c  |       (oldest)      | -> data stack: []
k   ---------------------
```

At this point, the interpreter is in the middle of the nested function call to `bar`. There are three frames on the call stack: one for the module level, one for the function `foo`, and one for `bar`. Once `bar` returns, the frame associated with it is popped off of the call stack. In general, there will be a frame for each module, each function call, and each class definition.  Note that this is one frame per function *call*, not just one frame per function. A recursive function would have one frame on the call stack for each level of recursion.

Each frame has its own data stack and block stack. Keeping separate data and block stacks enables the interpreter to pause and resume frames, as with a generator.

## Bytecode: Instructions for the interpreter
How does the interpreter know what operations it should perform?  Each frame has a _code object_, which has a collection of information.  The most important part of this information is called _bytecode_.  Bytecode is a series of bytes that the interpreter maps to certain operations that it should perform. (Bytecode is an _intermediate representation_ of Python code: it expresses the top-level Python code that you wrote in a way the interpreter can understand, analogous to the way that assembly serves as a representation between C code and a processor.)

In Python, the code object and its bytecode are exposed, so we can examine them in the REPL.  We'll take another simple function, `three`, as an example.

``` python
>>> def three(arg):
...     if arg:
...         return 7
...     return 10
...
>>> three.__code__.co_code
b'|\x00\x00r\n\x00d\x01\x00Sd\x02\x00S'
>>> [byte for byte in three.__code__.co_code]
[124, 0, 0, 114, 10, 0, 100, 1, 0, 83, 100, 2, 0, 83]

```

This looks uninteligible, but there's a powerful tool we can use to understand it. The standard library has a module called `dis` which takes bytecode and outputs a nicely-formatted explanation of it for us, detailed below:

``` python
>>> import dis
>>> dis.dis(three)
  2           0 LOAD_FAST                0 (arg)
              3 POP_JUMP_IF_FALSE       10

  3           6 LOAD_CONST               1 (7)
              9 RETURN_VALUE

  4     >>   10 LOAD_CONST               2 (10)
             13 RETURN_VALUE
>>> dis.opname[124]
'LOAD_FAST'
```

The first column shows the line numbers in our Python source code. The second column is an index into the bytecode, telling us that the `LOAD_FAST` instruction appears at position zero.  The third column is the instruction itself, mapped to its human-readable name. The fourth column, when present, is the argument to that instruction.  The fifth column, when present, is a hint about what the argument means.

When the interpreter executes bytecode, it starts with the first byte. It looks up and performs the corresponding operation, then moves to the next bytecode. Most of the work of writing an interpreter is providing a complete mapping of the operations associated with each instruction. In CPython, the lookup of operations corresponding to each instruction is implemented as a giant switch statement. The switch statment has one case for each bytecode and is _1,500 lines long_.

The interpreter may land on a given bytecode zero, one, or many times. In the example above, the interpreter will either execute the first pair of `LOAD_CONST` / `RETURN_VALUE` or the second, but never both. (Looking back at the code that generated this bytecode, you can see that either the first return statement or the second will execute, but never both.)

The interpreter stops executing a particular set of bytecode when it encounters an instruction that gives up control, like `RETURN_VALUE` or `YIELD_VALUE`, or until an (unhandled) exception is raised.

Some of the bytecode instructions have arguments. If an instruction has arguments, the arguments appear in the next two bytes. The arguments have different meaning for each instruction. In this example, the arguments to `124` (`LOAD_FAST`) are `0` and `0`. In the case of `LOAD_FAST`, which is an instruction to load the value associated with a given variable name, the argument is an index into the list of variable names. For `POP_JUMP_IF_FALSE` (the instruction associated with the `if` statement), the argument is the location to jump to in the bytecode.

### Byterun's objects
There are 4 kinds of objects in Byterun:
- A `VirtualMachine` class, which manages the highest-level structure, particularly the call stack of frames, and contains a mapping of instructions to operations.
- A `Frame` class.  Every `Frame` instance has one code object and manages a few other necessary bits of state.
- A `Function` class, which will be used in place of real Python functions. Calling a function creates a new frame in the interpreter. We implement Function so that we control the creation of new Frames.
- A `Block` class, implemented as a named tuple, which just wraps the three attributes of blocks.

With that context, we're now ready to write a Python interpreter. We'll begin at the top level with the VirtualMachine object. Only one instance of the VirtualMachine will ever be created. The object stores the call stack and other attributes discussed above. The entry point for executing code is the method `run_code`. This method takes a compiled code object as an argument. It sets up and runs a frame until the frame somehow returns. We'll implement `make_frame` and `run_frame` momentarily.


``` python
class VirtualMachineError(Exception):
    pass

class VirtualMachine(object):
    def __init__(self):
        self.frames = []   # The call stack of frames.
        self.frame = None  # The current frame.
        self.return_value = None
        self.last_exception = None

    def run_code(self, code, f_globals=None, f_locals=None):
        """ An entry point to execute code using the virtual machine."""
        frame = self.make_frame(code, f_globals=f_globals, f_locals=f_locals)
        val = self.run_frame(frame)
```

Next we'll write the Frame object. The frame is a very simple class - just a collection of attributes with no methods. As mentioned above, the attributes include the code object (created by the compiler) corresponding to the frame, the local, global, and builtin namespaces, a reference to the previous frame, a data stack, a block stack, and the last instruction executed. (We have to do a little extra work to get to the builtin namespace because Python treats this namespace differently in different modules; this detail is not important to the virtual machine.)

``` python
class Frame(object):
    def __init__(self, f_code, f_globals, f_locals, f_back):
        self.f_code = f_code        # The code object
        self.f_globals = f_globals  # Global namespace
        self.f_locals = f_locals    # Local namespace
        if f_back:
            self.f_builtins = f_back.f_builtins  # Builtin namespace
        else:
            self.f_builtins = f_locals['__builtins__']
            if hasattr(self.f_builtins, '__dict__'):
                self.f_builtins = self.f_builtins.__dict__

        self.f_back = f_back   # Reference to previous frame
        self.stack = []        # Data stack
        self.block_stack = []  # Block stack

        self.f_lineno = f_code.co_firstlineno  # First line number in original source code
        self.f_lasti = 0       # Last executed bytecode instruction
```

Next, we'll add frame manipulation to the virtual machine. There are three helper functions for frames: one to create new frames (which is responsible for sorting out the new frame's namespacing) and one each to push and pop frames from the frame stack.

``` python
class VirtualMachine(object):
    [... snip ...]

    # Frame manipulation
    def make_frame(self, code, callargs={}, f_globals=None, f_locals=None):
        if f_globals is not None and f_locals is None::
            f_locals = f_globals
        elif self.frames:
            f_globals = self.frame.f_globals
            f_locals = {}
        else:
            f_globals = f_locals = {
                '__builtins__': __builtins__,
                '__name__': '__main__',
                '__doc__': None,
                '__package__': None,
            }
        f_locals.update(callargs)
        frame = Frame(code, f_globals, f_locals, self.frame)
        return frame

    def push_frame(self, frame):
        self.frames.append(frame)
        self.frame = frame    # Update current frame in VM

    def pop_frame(self):
        self.frames.pop()
        if self.frames:
            self.frame = self.frames[-1]
        else:
            self.frame = None
```

The Function object appears below.  The important thing to notice here is that calling a function - in this case, invoking the `__call__` method - spawns a new Frame object.

```
    class Function(object):
    __slots__ = [
        'func_code', 'func_name', 'func_defaults', 'func_globals',
        'func_locals', 'func_dict', 'func_closure',
        '__name__', '__dict__', '__doc__',
        '_vm', '_func',
    ]

    def __init__(self, name, code, globs, defaults, closure, vm):
        self._vm = vm
        self.func_code = code
        self.func_name = self.__name__ = name or code.co_name
        self.func_defaults = tuple(defaults)
        self.func_globals = globs
        self.func_locals = self._vm.frame.f_locals
        self.__dict__ = {}
        self.func_closure = closure
        self.__doc__ = code.co_consts[0] if code.co_consts else None

        # Sometimes, we need a real Python function.  This is for that.
        kw = {
            'argdefs': self.func_defaults,
        }
        if closure:
            kw['closure'] = tuple(make_cell(0) for _ in closure)
        self._func = types.FunctionType(code, globs, **kw)

    def __call__(self, *args, **kwargs):
        callargs = inspect.getcallargs(self._func, *args, **kwargs)
        frame = self._vm.make_frame(
            self.func_code, callargs, self.func_globals, {}
        )
        return self._vm.run_frame(frame)
```

Next, we'll add some helper methods for stack manipulation. The bytecodes that manipulate the stack always operate on the current frame's data stack. This will make our implementation of `POP_TOP`, `LOAD_FAST`, and all the other instructions that touch the stack slightly more readable.

```
class VirtualMachine(object):
    [... snip ...]

    # Data stack manipulation
    def top(self):
        return self.frame.stack[-1]

    def pop(self):
        return self.frame.stack.pop()

    def push(self, *vals):
        self.frame.stack.extend(vals)

    def popn(self, n):
        """Pop a number of values from the value stack.
        A list of `n` values is returned, the deepest value first.
        """
        if n:
            ret = self.frame.stack[-n:]
            self.frame.stack[-n:] = []
            return ret
        else:
            return []
```

Next we'll briefly discuss blocks. A block is used for certain kinds of flow control, specifically exception handling and looping. The block is reponsible for making sure that the data stack is in the appropriate state when the operation is finished.  For example, in a loop, the iterator object should remain on the stack until the loop is finished, but then be popped off.  In an exception handler, the stack may have an exception on it that the handler will deal with and pop off the stack.

When managing the block stack on a frame, the interpreter sets a flag to indicate its state.  We implement this flag as either `None` or one of the strings `"continue"`, `"break"`, `"exception"`, or `"return"`. This indicates what kind of manipulation of the block stack and data stack should happen.  For example, if the top of the block stack is a `loop` block and the `why` code is `continue`, the looping block should remain on the stack, but if the `why` code is `break`, it should be popped off. The precise details of block manipulation are rather fiddly, and we won't spend more time on this, but interested readers are encouraged to take a careful look.

```
Block = collections.namedtuple("Block", "type, handler, level")

class VirtualMachine(object):
    [... snip ...]

    # Block stack manipulation
    def push_block(self, b_type, handler=None):
        level = len(self.frame.stack)
        self.frame.block_stack.append(Block(b_type, handler, level))

    def pop_block(self):
        return self.frame.block_stack.pop()

    def unwind_block(self, block):
        """Unwind the values on the data stack corresponding to a given block."""
        if block.type == 'except-handler':
            offset = 3  # The exception itself is on the stack as type, value, and traceback.
        else:
            offset = 0

        while len(self.frame.stack) > block.level + offset:
            self.pop()

        if block.type == 'except-handler':
            traceback, value, exctype = self.popn(3)
            self.last_exception = exctype, value, traceback

    def manage_block_stack(self, why):
        frame = self.frame
        block = frame.block_stack[-1]
        if block.type == 'loop' and why == 'continue':
            self.jump(self.return_value)
            why = None
            return why

        self.pop_block()
        self.unwind_block(block)

        if block.type == 'loop' and why == 'break':
            why = None
            self.jump(block.handler)
            return why

        if (block.type in ['setup-except', 'finally'] and why == 'exception'):
            self.push_block('except-handler')
            exctype, value, tb = self.last_exception
            self.push(tb, value, exctype)
            self.push(tb, value, exctype) # yes, twice
            why = None
            self.jump(block.handler)
            return why

        elif block.type == 'finally':
            if why in ('return', 'continue'):
                self.push(self.return_value)

            self.push(why)

            why = None
            self.jump(block.handler)
            return why
        return why
```

Before we get to running a frame, we need two more methods. The first, `parse_byte_and_args` takes a bytecode, checks if it has arguments, and parses the arguments if so. This method also updates the frame's attribute `f_lasti`, which tracks the  last instruction executed.

A single instruction is one byte long if it doesn't have an argument or three bytes if it does have an argument, where the last two bytes are the argument.  The meaning of the argument to each instruction depends on which instruction it is. For example, as mentioned above, for `POP_JUMP_IF_FALSE`, the argument to the instruction is an index into the bytecode representing the jump target.  For `BUILD_LIST`, the argument is the number of elements in the list.

Some instructions use simple numbers as their arguments. For others, the virtual machine has to do a little work to discover what the arguments mean.  The `dis` module in the standard library exposes a cheatsheet to what arguments have what meaning, which makes our code more compact.  For example, the list `dis.hasname` tells us that the arguments to `LOAD_NAME`, `IMPORT_NAME`, `LOAD_GLOBAL`, and nine other instructions have the same meaing: in each case, the argument represents an index into the list of names on the code object.

``` python
class VirtualMachine(object):
    [... snip ...]

    def parse_byte_and_args(self):
        """ Parse 1 - 3 bytes of bytecode into
            an instruction and maybe arguments."""
        f = self.frame
        opoffset = f.f_lasti
        byteCode = f.f_code.co_code[opoffset]
        f.f_lasti += 1
        byteName = dis.opname[byteCode]
        arg = None
        arguments = []
        if byteCode >= dis.HAVE_ARGUMENT:
            arg = f.f_code.co_code[f.f_lasti:f.f_lasti+2]
            f.f_lasti += 2
            intArg = arg[0] + (arg[1] << 8)
            if byteCode in dis.hasconst:   # Look up a constant
                arg = f.f_code.co_consts[intArg]
            elif byteCode in dis.hasname:  # Look up a name
                arg = f.f_code.co_names[intArg]
            elif byteCode in dis.haslocal: # Look up a local name
                arg = f.f_code.co_varnames[intArg]
            elif byteCode in dis.hasjrel:  # Calculate a relative jump
                arg = f.f_lasti + intArg
            else:
                arg = intArg
            arguments = [arg]

        return byteName, arguments
```

The next method is `dispatch`, which looks up the operations for a given instruction and executes them. In the CPython interpreter, this dispatch is done with a giant switch statemnt spanning 1,500 lines.  Since we're writing Python, we can be more compact.  We'll define a method for each byte name and then use `getattr` to look it up. If our bytecode was named `FOO_BAR`, the corresponding method would be named `byte_FOO_BAR`. For the moment, we'll leave the content of these methods as a black box.  Each bytecode method will return either `None` or a `why` string to be passed to block management.

The return values of the individual bytecode methods are used only as internal indicators of interpreter state. They are totally distinct from the return values in the code being executed.  Return values in the target code are handled by the bytecode `RETURN_VALUE`, which sets the value to be returned as an attribute on the virtual machine itself.  This value is then retrieved by the calling frame.


``` python
class VirtualMachine(object):
    [... snip ...]

    def dispatch(self, byteName, arguments):
        """ Dispatch by bytename to the corresponding method and call it.
            Exceptions are caught and set on the virtual machine."""
        # When later unwinding the block stack,
        # we need to keep track of why we are doing it.
        why = None

        try:
            if byteName.startswith('UNARY_'):
                self.unaryOperator(byteName[6:])
            elif byteName.startswith('BINARY_'):
                self.binaryOperator(byteName[7:])
            else:
                # primary dispatch
                bytecode_fn = getattr(self, 'byte_%s' % byteName, None)
                if not bytecode_fn:  # Not all bytecodes are supported in 500 lines
                    raise VirtualMachineError(
                        "unsupported bytecode type: %s" % byteName
                    )
                why = bytecode_fn(*arguments)

        except:
            # deal with exceptions encountered while executing the op.
            self.last_exception = sys.exc_info()[:2] + (None,)
            why = 'exception'

        return why
```

``` python
class VirtualMachine(object):
    [... snip ...]

    def run_frame(self, frame):
        """Run a frame until it returns (somehow).
        Exceptions are raised, the return value is returned.
        """
        self.push_frame(frame)
        while True:
            byteName, arguments = self.parse_byte_and_args()

            why = self.dispatch(byteName, arguments)

            # Deal with any block management we need to do
            while why and frame.block_stack:
                why = self.manage_block_stack(why)

            if why:
                break

        self.pop_frame()

        if why == 'exception':
            exc, val, tb = self.last_exception
            e = exc(val)
            e.__traceback__ = tb
            raise e

        return self.return_value
```

Now all we need to do is implement the methods we need for the `dispatch` method to work - `byte_LOAD_FAST`, `byte_BINARY_MODULO`, and so on. The methods below implement sixty of the actual 72 bytecodes. [TODO: check these numbers.] [footnote? This implementation excludes a handful of bytecodes for brevity, but the full implementation is available at github.com/nedbat/byterun.]

``` python
class VirtualMachine(object):
    [... snip ...]

    ## Stack manipulation

    def byte_LOAD_CONST(self, const):
        self.push(const)

    def byte_POP_TOP(self):
        self.pop()

    def byte_DUP_TOP(self):
        self.push(self.top())

    ## Names
    def byte_LOAD_NAME(self, name):
        frame = self.frame
        if name in frame.f_locals:
            val = frame.f_locals[name]
        elif name in frame.f_globals:
            val = frame.f_globals[name]
        elif name in frame.f_builtins:
            val = frame.f_builtins[name]
        else:
            raise NameError("name '%s' is not defined" % name)
        self.push(val)

    def byte_STORE_NAME(self, name):
        self.frame.f_locals[name] = self.pop()

    def byte_DELETE_NAME(self, name):
        del self.frame.f_locals[name]

    def byte_LOAD_FAST(self, name):
        if name in self.frame.f_locals:
            val = self.frame.f_locals[name]
        else:
            raise UnboundLocalError(
                "local variable '%s' referenced before assignment" % name
            )
        self.push(val)

    def byte_STORE_FAST(self, name):
        self.frame.f_locals[name] = self.pop()

    def byte_LOAD_GLOBAL(self, name):
        f = self.frame
        if name in f.f_globals:
            val = f.f_globals[name]
        elif name in f.f_builtins:
            val = f.f_builtins[name]
        else:
            raise NameError("global name '%s' is not defined" % name)
        self.push(val)

    ## Operators

    UNARY_OPERATORS = {
        'POSITIVE': operator.pos,
        'NEGATIVE': operator.neg,
        'NOT':      operator.not_,
        'INVERT':   operator.invert,
    }

    def unaryOperator(self, op):
        x = self.pop()
        self.push(self.UNARY_OPERATORS[op](x))

    BINARY_OPERATORS = {
        'POWER':    pow,
        'MULTIPLY': operator.mul,
        'FLOOR_DIVIDE': operator.floordiv,
        'TRUE_DIVIDE':  operator.truediv,
        'MODULO':   operator.mod,
        'ADD':      operator.add,
        'SUBTRACT': operator.sub,
        'SUBSCR':   operator.getitem,
        'LSHIFT':   operator.lshift,
        'RSHIFT':   operator.rshift,
        'AND':      operator.and_,
        'XOR':      operator.xor,
        'OR':       operator.or_,
    }

    def binaryOperator(self, op):
        x, y = self.popn(2)
        self.push(self.BINARY_OPERATORS[op](x, y))

    COMPARE_OPERATORS = [
        operator.lt,
        operator.le,
        operator.eq,
        operator.ne,
        operator.gt,
        operator.ge,
        lambda x, y: x in y,
        lambda x, y: x not in y,
        lambda x, y: x is y,
        lambda x, y: x is not y,
        lambda x, y: issubclass(x, Exception) and issubclass(x, y),
    ]

    def byte_COMPARE_OP(self, opnum):
        x, y = self.popn(2)
        self.push(self.COMPARE_OPERATORS[opnum](x, y))

    ## Attributes and indexing

    def byte_LOAD_ATTR(self, attr):
        obj = self.pop()
        val = getattr(obj, attr)
        self.push(val)

    def byte_STORE_ATTR(self, name):
        val, obj = self.popn(2)
        setattr(obj, name, val)

    def byte_STORE_SUBSCR(self):
        val, obj, subscr = self.popn(3)
        obj[subscr] = val

    ## Building

    def byte_BUILD_TUPLE(self, count):
        elts = self.popn(count)
        self.push(tuple(elts))

    def byte_BUILD_LIST(self, count):
        elts = self.popn(count)
        self.push(elts)

    def byte_BUILD_MAP(self, size):
        self.push({})

    def byte_STORE_MAP(self):
        the_map, val, key = self.popn(3)
        the_map[key] = val
        self.push(the_map)

    def byte_UNPACK_SEQUENCE(self, count):
        seq = self.pop()
        for x in reversed(seq):
            self.push(x)

    def byte_BUILD_SLICE(self, count):
        if count == 2:
            x, y = self.popn(2)
            self.push(slice(x, y))
        elif count == 3:
            x, y, z = self.popn(3)
            self.push(slice(x, y, z))
        else:           # pragma: no cover
            raise VirtualMachineError("Strange BUILD_SLICE count: %r" % count)

    def byte_LIST_APPEND(self, count):
        val = self.pop()
        the_list = self.frame.stack[-count] # peek
        the_list.append(val)


    ## Jumps

    def byte_JUMP_FORWARD(self, jump):
        self.jump(jump)

    def byte_JUMP_ABSOLUTE(self, jump):
        self.jump(jump)

    def byte_POP_JUMP_IF_TRUE(self, jump):
        val = self.pop()
        if val:
            self.jump(jump)

    def byte_POP_JUMP_IF_FALSE(self, jump):
        val = self.pop()
        if not val:
            self.jump(jump)

    def byte_JUMP_IF_TRUE_OR_POP(self, jump):
        val = self.top()
        if val:
            self.jump(jump)
        else:
            self.pop()

    def byte_JUMP_IF_FALSE_OR_POP(self, jump):
        val = self.top()
        if not val:
            self.jump(jump)
        else:
            self.pop()

    ## Blocks

    def byte_SETUP_LOOP(self, dest):
        self.push_block('loop', dest)

    def byte_GET_ITER(self):
        self.push(iter(self.pop()))

    def byte_FOR_ITER(self, jump):
        iterobj = self.top()
        try:
            v = next(iterobj)
            self.push(v)
        except StopIteration:
            self.pop()
            self.jump(jump)

    def byte_BREAK_LOOP(self):
        return 'break'

    def byte_CONTINUE_LOOP(self, dest):
        # This is a trick with the return value.
        # While unrolling blocks, continue and return both have to preserve
        # state as the finally blocks are executed.  For continue, it's
        # where to jump to, for return, it's the value to return.  It gets
        # pushed on the stack for both, so continue puts the jump destination
        # into return_value.
        self.return_value = dest
        return 'continue'

    def byte_SETUP_EXCEPT(self, dest):
        self.push_block('setup-except', dest)

    def byte_SETUP_FINALLY(self, dest):
        self.push_block('finally', dest)

    def byte_POP_BLOCK(self):
        self.pop_block()

    def byte_RAISE_VARARGS(self, argc):
        cause = exc = None
        if argc == 2:
            cause = self.pop()
            exc = self.pop()
        elif argc == 1:
            exc = self.pop()
        return self.do_raise(exc, cause)

    def do_raise(self, exc, cause):
        if exc is None:         # reraise
            exc_type, val, tb = self.last_exception

        elif type(exc) == type:  # As in `raise ValueError`
            exc_type = exc
            val = exc()             # Make an instance.
        elif isinstance(exc, BaseException):
            # As in `raise ValueError('foo')`
            exc_type = type(exc)
            val = exc
        else:
            return 'exception' # failure

        self.last_exception = exc_type, val, val.__traceback__
        return 'exception'

    def byte_POP_EXCEPT(self):
        block = self.pop_block()
        if block.type != 'except-handler':
            raise Exception("popped block is not an except handler")
        self.unwind_block(block)

    ## Functions

    def byte_MAKE_FUNCTION(self, argc):
        name = self.pop()
        code = self.pop()
        defaults = self.popn(argc)
        globs = self.frame.f_globals
        fn = Function(name, code, globs, defaults, None, self)
        self.push(fn)

    def byte_CALL_FUNCTION(self, arg):
        lenKw, lenPos = divmod(arg, 256) # KWargs not supported here
        posargs = self.popn(lenPos)

        func = self.pop()
        frame = self.frame
        retval = func(*posargs)
        self.push(retval)

    def byte_RETURN_VALUE(self):
        self.return_value = self.pop()
        return "return"

    ## Importing

    def byte_IMPORT_NAME(self, name):
        level, fromlist = self.popn(2)
        frame = self.frame
        self.push(__import__(name, frame.f_globals, frame.f_locals, fromlist, level))

    def byte_IMPORT_FROM(self, name):
        mod = self.top()
        self.push(getattr(mod, name))

    ## And the rest...
    def byte_LOAD_BUILD_CLASS(self):
        self.push(__build_class__)

    def byte_STORE_LOCALS(self):
        self.frame.f_locals = self.pop()
```

### Walk through example of "three" again

### Somehow conclude




#### cruft / possible footnotes
. [footnote? You may have heard of PyPy, a prominent Python interpreter written in Python. The structure of PyPy is covered in volume 2 of AOSA, by Benjamin Peterson. Before optimzations, PyPy is four times slower than the CPython interpreter.] One advantage of writing our Python interpreter in Python is that we don't have to also implement an object system - we can seamlessly fall back to the "real" Python's object system.
