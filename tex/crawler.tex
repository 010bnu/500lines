\begin{aosachapter}{A Web Crawler With asyncio Coroutines}{s:crawler}{A. Jesse Jiryu Davis and Guido van Rossum}

Classical computer science emphasizes efficient algorithms that complete
computations as quickly as possible. But many networked programs spend
their time not computing, but holding open many connections that are
slow, or have infrequent events. These programs present a very different
challenge: to wait for a huge number of network events efficiently. A
contemporary approach to this problem is asynchronous I/O, or ``async''.

This chapter presents a simple web crawler. The crawler is an archetypal
async application because it waits for many responses, but does little
computation. The more pages it can fetch at once, the sooner it
completes. If it devotes a thread to each in-flight request, then as the
number of concurrent requests rises it will run out of memory or other
thread-related resource before it runs out of sockets. It avoids the
need for threads by using asynchronous I/O.

We present the example in three stages. First, we show an async event
loop and sketch a crawler that uses the event loop with callbacks: it is
very efficient, but extending it to more complex problems would lead to
unmanageable spaghetti code. Second, therefore, we show that Python
coroutines are both efficient and extensible. We implement simple
coroutines in Python using generator functions. In the third stage, we
use the full-featured coroutines from Python's standard ``asyncio''
library\footnote{Guido introduced the standard asyncio library, called
  ``Tulip'' then, at PyCon 2013.}, and coordinate them using an async
queue.

\aosasecti{The Task}\label{the-task}

A web crawler finds and downloads all pages on a website, perhaps to
archive or index them. Beginning with a root URL, it fetches each page,
parses it for links to pages it has not seen, and adds the new links to
a queue. When it fetches a page with no unseen links and the queue is
empty, it stops.

We can hasten this process by downloading many pages concurrently. As
the crawler finds new links, it launches simultaneous fetch operations
for the new pages on separate sockets. It parses responses as they
arrive, adding new links to the queue. There may come some point of
diminishing returns where too much concurrency degrades performance, so
we cap the number of concurrent requests, and leave the remaining links
in the queue until some in-flight requests complete.

\aosasecti{The Traditional Approach}\label{the-traditional-approach}

How do we make the crawler concurrent? Traditionally we would create a
thread pool. Each thread would be in charge of downloading one page at a
time over a socket. For example, to download a page from xkcd.com:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \NormalTok{fetch(url):}
    \NormalTok{sock = socket.socket()}
    \NormalTok{sock.}\OtherTok{connect}\NormalTok{((}\StringTok{'xkcd.com'}\NormalTok{, }\DecValTok{80}\NormalTok{))}
    \NormalTok{request = }\StringTok{'GET \{\} HTTP/1.0}\CharTok{\textbackslash{}r\textbackslash{}n}\StringTok{Host: xkcd.com}\CharTok{\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n}\StringTok{'}\NormalTok{.}\DataTypeTok{format}\NormalTok{(url)}
    \NormalTok{sock.send(request.encode(}\StringTok{'ascii'}\NormalTok{))}
    \NormalTok{response = b}\StringTok{''}
    \NormalTok{chunk = sock.recv(}\DecValTok{4096}\NormalTok{)}
    \KeywordTok{while} \NormalTok{chunk:}
        \NormalTok{response += chunk}
        \NormalTok{chunk = sock.recv(}\DecValTok{4096}\NormalTok{)}
    
    \CommentTok{# Page is now downloaded.}
    \NormalTok{links = parse_links(response)}
    \NormalTok{q.add(links)}
\end{Highlighting}
\end{Shaded}

By default, socket operations are \emph{blocking}: when the thread calls
a method like \texttt{connect} or \texttt{recv}, it pauses until the
operation completes.\footnote{Even calls to \texttt{send} can block, if
  the recipient is slow to acknowledge outstanding messages and the
  system's buffer of outgoing data is full.} Consequently to download
many pages at once, we need many threads. A sophisticated application
amortizes the cost of thread-creation by keeping idle threads in a
thread pool, then checking them out to reuse them for subsequent tasks;
it does the same with sockets in a connection pool.

And yet, threads are expensive, and operating systems enforce a variety
of hard caps on the number of threads a process, user, or machine may
have. On Jesse's system, a Python thread costs around 50k of memory, and
starting tens of thousands of threads causes failures. If we scale up to
tens of thousands of simultaneous operations on concurrent sockets, we
run out of threads before we run out of sockets. Per-thread overhead or
system limits on threads are the bottleneck.

In his influential article ``The C10K problem''\footnote{http://www.kegel.com/c10k.html},
Dan Kegel outlines the limitations of multithreading for I/O
concurrency. He begins,

\begin{quote}
It's time for web servers to handle ten thousand clients simultaneously,
don't you think? After all, the web is a big place now.
\end{quote}

Kegel coined the term ``C10K'' in 1999. Ten thousand connections sounds
dainty now, but the problem has changed only in size, not in kind. Back
then, using a thread per connection for C10K was impractical. Now the
cap is orders of magnitude higher. Indeed, our toy web crawler would
work just fine with threads. Yet for very large scale applications, with
hundreds of thousands of connections, the cap remains: there is a limit
beyond which most systems can still create sockets, but have run out of
threads. How can we overcome this?

\aosasecti{Async}\label{async}

Asynchronous I/O frameworks do concurrent operations on a single thread.
Let us find out how.

Async frameworks use \emph{non-blocking} sockets. In our async crawler,
we set the socket non-blocking before we begin to connect to the server:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sock = socket.socket()}
\NormalTok{sock.setblocking(}\OtherTok{False}\NormalTok{)}
\KeywordTok{try}\NormalTok{:}
    \NormalTok{sock.}\OtherTok{connect}\NormalTok{((}\StringTok{'xkcd.com'}\NormalTok{, }\DecValTok{80}\NormalTok{))}
\KeywordTok{except} \OtherTok{BlockingIOError}\NormalTok{:}
    \KeywordTok{pass}
\end{Highlighting}
\end{Shaded}

Irritatingly, a non-blocking socket throws an exception from
\texttt{connect}, even when it is working normally. This exception
replicates the irritating behavior of the underlying C function, which
sets \texttt{errno} to \texttt{EINPROGRESS} to tell you it has begun.

Now our crawler needs a way to know when the connection is established,
so it can send the HTTP request. We could simply keep trying in a tight
loop:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{request = }\StringTok{'GET \{\} HTTP/1.0}\CharTok{\textbackslash{}r\textbackslash{}n}\StringTok{Host: xkcd.com}\CharTok{\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n}\StringTok{'}\NormalTok{.}\DataTypeTok{format}\NormalTok{(url)}
\NormalTok{encoded = request.encode(}\StringTok{'ascii'}\NormalTok{)}

\KeywordTok{while} \OtherTok{True}\NormalTok{:}
    \KeywordTok{try}\NormalTok{:}
        \NormalTok{sock.send(encoded)}
        \KeywordTok{break}  \CommentTok{# Done.}
    \KeywordTok{except} \OtherTok{OSError} \CharTok{as} \NormalTok{e:}
        \KeywordTok{pass}

\DataTypeTok{print}\NormalTok{(}\StringTok{'sent'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This method not only wastes electricity, but it cannot efficiently await
events on \emph{multiple} sockets. In ancient times, BSD Unix's solution
to this problem was \texttt{select}, a C function that waits for an
event to occur on a non-blocking socket or a small array of them.
Nowadays the demand for Internet applications with huge numbers of
connections has led to replacements like \texttt{poll}, then
\texttt{kqueue} on BSD and \texttt{epoll} on Linux. These APIs are
similar to \texttt{select}, but perform well with very large numbers of
connections.

Python 3.4's \texttt{DefaultSelector} uses the best \texttt{select}-like
function available on your system. To register for notifications about
network I/O, we create a non-blocking socket and register it with the
default selector:

\begin{Shaded}
\begin{Highlighting}[]
\CharTok{from} \NormalTok{selectors }\CharTok{import} \NormalTok{DefaultSelector}

\NormalTok{selector = DefaultSelector()}

\NormalTok{sock = socket.socket()}
\NormalTok{sock.setblocking(}\OtherTok{False}\NormalTok{)}
\KeywordTok{try}\NormalTok{:}
    \NormalTok{sock.}\OtherTok{connect}\NormalTok{((}\StringTok{'xkcd.com'}\NormalTok{, }\DecValTok{80}\NormalTok{))}
\KeywordTok{except} \OtherTok{BlockingIOError}\NormalTok{:}
    \KeywordTok{pass}

\KeywordTok{def} \NormalTok{connected():}
    \NormalTok{selector.unregister(sock.fileno())}
    \DataTypeTok{print}\NormalTok{(}\StringTok{'connected!'}\NormalTok{)}

\NormalTok{selector.register(sock.fileno(), EVENT_WRITE, connected)}
\end{Highlighting}
\end{Shaded}

We disregard the spurious error and call \texttt{selector.register},
passing in the socket's file descriptor and a constant that expresses
what event we are waiting for. To be notified when the connection is
established, we pass \texttt{EVENT\_WRITE}: that is, we want to know
when the socket is ``writable''. We also pass a Python function,
\texttt{connected}, to run when that event occurs. Such a function is
known as a \emph{callback}.

We process I/O notifications as the selector receives them, in a loop:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \NormalTok{loop():}
    \KeywordTok{while} \OtherTok{True}\NormalTok{:}
        \NormalTok{events = selector.select()}
        \KeywordTok{for} \NormalTok{event_key, event_mask in events:}
            \NormalTok{callback = event_key.data}
            \NormalTok{callback()}
\end{Highlighting}
\end{Shaded}

The \texttt{connected} callback is stored as \texttt{event\_key.data},
which we retrieve and execute once the non-blocking socket is connected.

Unlike in our fast-spinning loop above, the call to \texttt{select} here
pauses, awaiting the next I/O events. Then the loop runs callbacks that
are waiting for these events. Operations that have not completed remain
pending until some future tick of the event loop.

What have we demonstrated already? We showed how to begin an operation
and execute a callback when the operation is ready. An async
\emph{framework} builds on the two features we have shown---non-blocking
sockets and the event loop---to run concurrent operations on a single
thread.

We have achieved ``concurrency'' here, but not what is traditionally
called ``parallelism''. That is, we built a tiny system that does
overlapping I/O. It is capable of beginning new operations while others
are in flight. It does not actually utilize multiple cores to execute
computation in parallel. But then, this system is designed for I/O-bound
problems, not CPU-bound ones.\footnote{Python's global interpreter lock
  prohibits running Python code in parallel in one process anyway.
  Parallelizing CPU-bound algorithms in Python requires multiple
  processes, or writing the parallel portions of the code in C. But that
  is a topic for another day.}

So our event loop is efficient at concurrent I/O because it does not
devote thread resources to each connection. But before we proceed, it is
important to correct a common misapprehension that async is
\emph{faster} than multithreading. Often it is not---indeed, in Python,
an event loop like ours is moderately slower than multithreading at
serving a small number of very active connections. In a runtime without
a global interpreter lock, threads would perform even better on such a
workload. What asynchronous I/O is right for, is applications with many
slow or sleepy connections with infrequent events.\footnote{Jesse listed
  indications and contraindications for using async in ``What Is Async,
  How Does It Work, And When Should I Use It?'', available at
  pyvideo.org.}\footnote{Mike Bayer compared the throughput of asyncio
  and multithreading for different workloads in his ``Asynchronous
  Python and Databases'':
  http://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/}

\aosasecti{Programming With Callbacks}\label{programming-with-callbacks}

With the runty async framework we have built so far, how can we build a
web crawler? Even a simple URL-fetcher is painful to write.

We begin with global sets of the URLs we have yet to fetch, and the URLs
we have seen:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{urls_todo = }\DataTypeTok{set}\NormalTok{([}\StringTok{'/'}\NormalTok{])}
\NormalTok{seen_urls = }\DataTypeTok{set}\NormalTok{([}\StringTok{'/'}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

The \texttt{seen\_urls} set includes \texttt{urls\_todo} plus completed
URLs. The two sets are initialized with the root URL ``/''.

Fetching a page will require a series of callbacks. The
\texttt{connected} callback fires when a socket is connected, and sends
a GET request to the server. But then it must await a response, so it
registers another callback. If, when that callback fires, it cannot read
the full response yet, it registers again, and so on.

Let us collect these callbacks into a \texttt{Fetcher} object. It needs
a URL, a socket object, and a place to accumulate the response bytes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \NormalTok{Fetcher:}
    \KeywordTok{def} \OtherTok{__init__}\NormalTok{(}\OtherTok{self}\NormalTok{, url):}
        \OtherTok{self}\NormalTok{.response = b}\StringTok{''}  \CommentTok{# Empty array of bytes.}
        \OtherTok{self}\NormalTok{.url = url}
        \OtherTok{self}\NormalTok{.sock = }\OtherTok{None}
\end{Highlighting}
\end{Shaded}

We begin by calling \texttt{Fetcher.fetch}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# Method on Fetcher class.}
    \KeywordTok{def} \NormalTok{fetch(}\OtherTok{self}\NormalTok{):}
        \OtherTok{self}\NormalTok{.sock = socket.socket()}
        \OtherTok{self}\NormalTok{.sock.setblocking(}\OtherTok{False}\NormalTok{)}
        \KeywordTok{try}\NormalTok{:}
            \OtherTok{self}\NormalTok{.sock.}\OtherTok{connect}\NormalTok{((}\StringTok{'xkcd.com'}\NormalTok{, }\DecValTok{80}\NormalTok{))}
        \KeywordTok{except} \OtherTok{BlockingIOError}\NormalTok{:}
            \KeywordTok{pass}
            
        \CommentTok{# Register next callback.}
        \NormalTok{selector.register(}\OtherTok{self}\NormalTok{.sock.fileno(),}
                          \NormalTok{EVENT_WRITE,}
                          \OtherTok{self}\NormalTok{.connected)}
\end{Highlighting}
\end{Shaded}

The \texttt{fetch} method begins connecting a socket. But notice the
method returns before the connection is established. It must return
control to the event loop to wait for the connection. To understand why,
imagine our whole application was structured so:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Begin fetching http://xkcd.com/353/}
\NormalTok{fetcher = Fetcher(}\StringTok{'/353/'}\NormalTok{)}
\NormalTok{fetcher.fetch()}

\KeywordTok{while} \OtherTok{True}\NormalTok{:}
    \NormalTok{events = selector.select()}
    \KeywordTok{for} \NormalTok{event_key, event_mask in events:}
        \NormalTok{callback = event_key.data}
        \NormalTok{callback(event_key, event_mask)}
\end{Highlighting}
\end{Shaded}

All event notifications are processed in the event loop when it calls
\texttt{select}. Hence \texttt{fetch} must hand control to the event
loop, so that the program knows when the socket has connected. Only then
does the loop run the \texttt{connected} callback, which was registered
at the end of \texttt{fetch} above.

Here is the implementation of \texttt{connected}:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# Method on Fetcher class.}
    \KeywordTok{def} \NormalTok{connected(}\OtherTok{self}\NormalTok{, key, mask):}
        \DataTypeTok{print}\NormalTok{(}\StringTok{'connected!'}\NormalTok{)}
        \NormalTok{selector.unregister(key.fd)}
        \NormalTok{request = }\StringTok{'GET \{\} HTTP/1.0}\CharTok{\textbackslash{}r\textbackslash{}n}\StringTok{Host: xkcd.com}\CharTok{\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n}\StringTok{'}\NormalTok{.}\DataTypeTok{format}\NormalTok{(url)}
        \OtherTok{self}\NormalTok{.sock.send(request.encode(}\StringTok{'ascii'}\NormalTok{))}
        
        \CommentTok{# Register the next callback.}
        \NormalTok{selector.register(key.fd,}
                          \NormalTok{EVENT_READ,}
                          \OtherTok{self}\NormalTok{.read_response)}
\end{Highlighting}
\end{Shaded}

The method sends a GET request. A real application would check the
return value of \texttt{send} in case the whole message cannot be sent
at once. But our request is small and our application unsophisticated.
It blithely calls \texttt{send}, then waits for a response. Of course,
it must register yet another callback and relinquish control to the
event loop. The next and final callback, \texttt{read\_response},
processes the server's reply:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# Method on Fetcher class.}
    \KeywordTok{def} \NormalTok{read_response(}\OtherTok{self}\NormalTok{, key, mask):}
        \KeywordTok{global} \NormalTok{stopped}

        \NormalTok{chunk = }\OtherTok{self}\NormalTok{.sock.recv(}\DecValTok{4096}\NormalTok{)  }\CommentTok{# 4k chunk size.}
        \KeywordTok{if} \NormalTok{chunk:}
            \OtherTok{self}\NormalTok{.response += chunk}
        \KeywordTok{else}\NormalTok{:}
            \NormalTok{selector.unregister(key.fd)  }\CommentTok{# Done reading.}
            \NormalTok{links = }\OtherTok{self}\NormalTok{.parse_links()}
            
            \CommentTok{# Python set-logic:}
            \KeywordTok{for} \NormalTok{link in links.difference(seen_urls):}
                \NormalTok{urls_todo.add(link)}
                \NormalTok{Fetcher(link).fetch()  }\CommentTok{# <- New Fetcher.}

            \NormalTok{seen_urls.update(links)}
            \NormalTok{urls_todo.remove(}\OtherTok{self}\NormalTok{.url)}
            \KeywordTok{if} \NormalTok{not urls_todo:}
                \NormalTok{stopped = }\OtherTok{True}
\end{Highlighting}
\end{Shaded}

The callback is executed each time the selector sees that the socket is
``readable'', which could mean two things: the socket has data or it is
closed.

The callback asks for up to four kilobytes of data from the socket. If
less is ready, \texttt{chunk} contains whatever data is available. If
there is more, \texttt{chunk} is four kilobytes long and the socket
remains readable, so the event loop runs this callback again on the next
tick. When the response is complete, the server has closed the socket
and \texttt{chunk} is empty.

The \texttt{parse\_links} method, not shown, returns a set of URLs. We
start a new fetcher for each new URL, with no concurrency cap. Note a
nice feature of async programming with callbacks: we need no mutex
around changes to shared data, such as when we add links to
\texttt{seen\_urls}. There is no preemptive multitasking, so we cannot
be interrupted at arbitrary points in our code.

We add a global \texttt{stopped} variable and use it to control the
loop:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stopped = }\OtherTok{False}

\KeywordTok{def} \NormalTok{loop():}
    \KeywordTok{while} \NormalTok{not stopped:}
        \NormalTok{events = selector.select()}
        \KeywordTok{for} \NormalTok{event_key, event_mask in events:}
            \NormalTok{callback = event_key.data}
            \NormalTok{callback()}
\end{Highlighting}
\end{Shaded}

Once all pages are downloaded the fetcher stops the global event loop
and the program exits.

This example makes async's problem plain: spaghetti code.

We need some way to express a series of computations and I/O operations,
and schedule multiple such series of operations to run concurrently. But
without threads, a series of operations cannot be collected into a
single function: whenever a function begins an I/O operation, it
explicitly saves whatever state will be needed in the future, then
returns. You are responsible for thinking about and writing this
state-saving code.

Let us explain what we mean by that. Consider how simply we fetched a
URL on a thread with a conventional blocking socket:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Blocking version.}
\KeywordTok{def} \NormalTok{fetch(url):}
    \NormalTok{sock = socket.socket()}
    \NormalTok{sock.}\OtherTok{connect}\NormalTok{((}\StringTok{'xkcd.com'}\NormalTok{, }\DecValTok{80}\NormalTok{))}
    \NormalTok{request = }\StringTok{'GET \{\} HTTP/1.0}\CharTok{\textbackslash{}r\textbackslash{}n}\StringTok{Host: xkcd.com}\CharTok{\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n}\StringTok{'}\NormalTok{.}\DataTypeTok{format}\NormalTok{(url)}
    \NormalTok{sock.send(request.encode(}\StringTok{'ascii'}\NormalTok{))}
    \NormalTok{response = b}\StringTok{''}
    \NormalTok{chunk = sock.recv(}\DecValTok{4096}\NormalTok{)}
    \KeywordTok{while} \NormalTok{chunk:}
        \NormalTok{response += chunk}
        \NormalTok{chunk = sock.recv(}\DecValTok{4096}\NormalTok{)}
    
    \CommentTok{# Page is now downloaded.}
    \NormalTok{links = parse_links(response)}
    \NormalTok{q.add(links)}
\end{Highlighting}
\end{Shaded}

What state does this function remember between one socket operation and
the next? It has the socket, a URL, and the accumulating
\texttt{response}. A function that runs on a thread uses basic features
of the programming language to store this temporary state in local
variables, on its stack. The function also has a ``continuation''---that
is, the code it plans to execute after I/O completes. The runtime
remembers the continuation by storing the thread's instruction pointer.
You need not think about restoring these local variables and the
continuation after I/O. It is built in to the language.

But with a callback-based async framework, these language features are
no help. While waiting for I/O, a function must save its state
explicitly, because the function returns and loses its stack frame
before I/O completes. In lieu of local variables, our callback-based
example stores \texttt{sock} and \texttt{response} as attributes of
\texttt{self}, the Fetcher instance. In lieu of the instruction pointer,
it stores its continuation by registering the callbacks
\texttt{connected} and \texttt{read\_response}. As the application's
features grow, so does the complexity of the state we manually save
across callbacks. Such onerous bookkeeping makes the coder prone to
migraines.

Even worse, what happens if a callback throws an exception, before it
schedules the next callback in the chain? Say we did a poor job on the
\texttt{parse\_links} method and it throws an exception parsing some
HTML:

\begin{verbatim}
Traceback (most recent call last):
  File "loop-with-callbacks.py", line 111, in <module>
    loop()
  File "loop-with-callbacks.py", line 106, in loop
    callback(event_key, event_mask)
  File "loop-with-callbacks.py", line 51, in read_response
    links = self.parse_links()
  File "loop-with-callbacks.py", line 67, in parse_links
    raise Exception('parse error')
Exception: parse error
\end{verbatim}

The stack trace shows only that the event loop was running a callback.
We do not remember what led to the error. The chain is broken on both
ends: we forgot where we were going and whence we came. This loss of
context is called ``stack ripping'', and in many cases it confounds the
investigator. Stack ripping also prevents us from installing an
exception handler for a chain of callbacks, the way a ``try / except''
block wraps a function call and its tree of descendents.\footnote{For a
  complex solution to this problem, see
  http://www.tornadoweb.org/en/stable/stack\_context.html}

So, even apart from the long debate about the relative efficiencies of
multithreading and async, there is this other debate regarding which is
more error-prone: threads are susceptible to data races if you make a
mistake synchronizing them, but callbacks are stubborn to debug due to
stack ripping.

\aosasecti{Coroutines}\label{coroutines}

We entice you with a promise. It is possible to write asynchronous code
that combines the efficiency of callbacks with the classic good looks of
multithreaded programming. This combination is achieved with a pattern
called ``coroutines''. Using Python 3.4's standard asyncio library, and
a package called ``aiohttp'', fetching a URL in a coroutine is very
direct\footnote{The \texttt{@asyncio.coroutine} decorator is not
  magical. In fact, if it decorates a generator function and the
  \texttt{PYTHONASYNCIODEBUG} environment variable is not set, the
  decorator does practically nothing. It just sets an attribute,
  \texttt{\_is\_coroutine}, for the convenience of other parts of the
  framework. It is possible to use asyncio with bare generators not
  decorated with \texttt{@asyncio.coroutine} at all.}:

\begin{Shaded}
\begin{Highlighting}[]
    \OtherTok{@asyncio.coroutine}
    \KeywordTok{def} \NormalTok{fetch(}\OtherTok{self}\NormalTok{, url):}
        \NormalTok{response = }\KeywordTok{yield} \CharTok{from} \NormalTok{aiohttp.request(}\StringTok{'get'}\NormalTok{, url)}
        \NormalTok{body = }\KeywordTok{yield} \CharTok{from} \NormalTok{response.read()}
\end{Highlighting}
\end{Shaded}

It is also scalable. Compared to the 50k of memory per thread and the
operating system's hard limits on threads, a Python coroutine takes
barely 3k of memory on Jesse's system. Python can easily start hundreds
of thousands of coroutines.

The concept of a coroutine, dating to the elder days of computer
science, is simple: it is a subroutine that can be paused and resumed.
Whereas threads are preemptively multitasked by the operating system,
coroutines multitask cooperatively: they choose when to pause, and which
coroutine to run next.

There are many implementations of coroutines; even in Python there are
several. The coroutines in the standard ``asyncio'' library are built
upon Python generators, a Future class, and the ``yield from''
statement. We will engage in an exposition of generators and how they
are used as coroutines in asyncio, and trust you will enjoy reading it
as much as we enjoyed writing it. Once we have explained asyncio
coroutines, we shall use them in our async web crawler.

\aosasecti{How Python Generators Work}\label{how-python-generators-work}

Before you grasp Python generators, you have to understand how regular
Python functions work. Normally, when a Python function calls a
subroutine, the subroutine retains control until it returns, or throws
an exception. Then control returns to the caller:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> }\KeywordTok{def} \NormalTok{foo():}
\NormalTok{...     bar()}
\NormalTok{...}
\NormalTok{>>> }\KeywordTok{def} \NormalTok{bar():}
\NormalTok{...     }\KeywordTok{pass}
\end{Highlighting}
\end{Shaded}

The standard Python interpreter is written in C. The C function that
executes a Python function is called, mellifluously,
\texttt{PyEval\_EvalFrameEx}. It takes a Python stack frame object and
evaluates Python bytecode in the context of the frame. Here is the
bytecode for \texttt{foo}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> }\CharTok{import} \NormalTok{dis}
\NormalTok{>>> dis.dis(foo)}
  \DecValTok{2}           \DecValTok{0} \NormalTok{LOAD_GLOBAL              }\DecValTok{0} \NormalTok{(bar)}
              \DecValTok{3} \NormalTok{CALL_FUNCTION            }\DecValTok{0} \NormalTok{(}\DecValTok{0} \NormalTok{positional, }\DecValTok{0} \NormalTok{keyword pair)}
              \DecValTok{6} \NormalTok{POP_TOP}
              \DecValTok{7} \NormalTok{LOAD_CONST               }\DecValTok{0} \NormalTok{(}\OtherTok{None}\NormalTok{)}
             \DecValTok{10} \NormalTok{RETURN_VALUE}
\end{Highlighting}
\end{Shaded}

The \texttt{foo} function loads \texttt{bar} onto its stack and calls
it, then pops its return value from the stack, loads \texttt{None} onto
the stack, and returns \texttt{None}.

When \texttt{PyEval\_EvalFrameEx} encounters the \texttt{CALL\_FUNCTION}
bytecode, it creates a new Python stack frame and recurses: that is, it
calls \texttt{PyEval\_EvalFrameEx} recursively with the new frame, which
is used to execute \texttt{bar}.

\aosafigure[240pt]{crawler-images/function-calls.png}{Function Calls}{500l.crawler.functioncalls}

It is crucial to understand that Python stack frames are allocated in
heap memory! The Python interpreter is a normal C program, so its stack
frames are normal stack frames. But the \emph{Python} stack frames it
manipulates are on the heap. Among other surprises, this means a Python
stack frame can outlive its function call. To see this interactively,
save the current frame from within \texttt{bar}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> }\CharTok{import} \NormalTok{inspect}
\NormalTok{>>> frame = }\OtherTok{None}
\NormalTok{>>> }\KeywordTok{def} \NormalTok{foo():}
\NormalTok{...     bar()}
\NormalTok{...}
\NormalTok{>>> }\KeywordTok{def} \NormalTok{bar():}
\NormalTok{...     }\KeywordTok{global} \NormalTok{frame}
\NormalTok{...     frame = inspect.currentframe()}
\NormalTok{...}
\NormalTok{>>> foo()}
\NormalTok{>>> }\CommentTok{# The frame was executing the code for 'bar'.}
\NormalTok{>>> frame.f_code.co_name}
\CommentTok{'bar'}
\NormalTok{>>> }\CommentTok{# Its back pointer refers to the frame for 'foo'.}
\NormalTok{>>> caller_frame = frame.f_back}
\NormalTok{>>> caller_frame.f_code.co_name}
\CommentTok{'foo'}
\end{Highlighting}
\end{Shaded}

The stage is now set for Python generators, which use the same building
blocks---code objects and stack frames---to marvelous effect.

This is a generator function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> }\KeywordTok{def} \NormalTok{gen_fn():}
\NormalTok{...     result = }\KeywordTok{yield} \DecValTok{1}
\NormalTok{...     }\DataTypeTok{print}\NormalTok{(}\StringTok{'result of yield: \{\}'}\NormalTok{.}\DataTypeTok{format}\NormalTok{(result))}
\NormalTok{...     result2 = }\KeywordTok{yield} \DecValTok{2}
\NormalTok{...     }\DataTypeTok{print}\NormalTok{(}\StringTok{'result of 2nd yield: \{\}'}\NormalTok{.}\DataTypeTok{format}\NormalTok{(result2))}
\NormalTok{...     }\KeywordTok{return} \StringTok{'done'}
\NormalTok{...     }
\end{Highlighting}
\end{Shaded}

When Python compiles \texttt{gen\_fn} to bytecode, it sees the
\texttt{yield} statement and knows that \texttt{gen\_fn} is a generator
function, not a regular one. It sets a flag to remember this fact:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> }\CommentTok{# The generator flag is bit position 5.}
\NormalTok{>>> generator_bit = }\DecValTok{1} \NormalTok{<< }\DecValTok{5}
\NormalTok{>>> }\DataTypeTok{bool}\NormalTok{(gen_fn.__code__.co_flags & generator_bit)}
\OtherTok{True}
\end{Highlighting}
\end{Shaded}

When you call a generator function, Python sees the generator flag, and
it does not actually run the function. Instead, it creates a generator:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> gen = gen_fn()}
\NormalTok{>>> }\DataTypeTok{type}\NormalTok{(gen)}
\NormalTok{<}\KeywordTok{class} \StringTok{'generator'}\NormalTok{>}
\end{Highlighting}
\end{Shaded}

A Python generator encapsulates a stack frame plus a reference to some
code, the body of \texttt{gen\_fn}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> gen.gi_code.co_name}
\CommentTok{'gen_fn'}
\end{Highlighting}
\end{Shaded}

All generators from calls to \texttt{gen\_fn} point to this same code.
But each has its own stack frame. This stack frame is not on any actual
stack, it sits in heap memory waiting to be used:

\aosafigure[240pt]{crawler-images/generator.png}{Generators}{500l.crawler.generators}

The frame has a ``last instruction'' pointer, the instruction it
executed most recently. In the beginning, the last instruction pointer
is -1, meaning the generator has not begun:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> gen.gi_frame.f_lasti}
\NormalTok{-}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

When we call \texttt{send}, the generator reaches its first
\texttt{yield}, and pauses. The return value of \texttt{send} is 1,
since that is what \texttt{gen} passes to the \texttt{yield} expression:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> gen.send(}\OtherTok{None}\NormalTok{)}
\DecValTok{1}
\end{Highlighting}
\end{Shaded}

The generator's instruction pointer is now 3 bytecodes from the start,
part way through the 56 bytes of compiled Python:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> gen.gi_frame.f_lasti}
\DecValTok{3}
\NormalTok{>>> }\DataTypeTok{len}\NormalTok{(gen.gi_code.co_code)}
\DecValTok{56}
\end{Highlighting}
\end{Shaded}

The generator can be resumed at any time, from any function, because its
stack frame is not actually on the stack: it is on the heap. Its
position in the call hierarchy is not fixed, and it need not obey the
first-in, last-out order of execution that regular functions do. It is
liberated, floating free like a cloud.

We can send the value ``hello'' into the generator and it becomes the
result of the \texttt{yield} expression, and the generator continues
until it yields 2:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> gen.send(}\StringTok{'hello'}\NormalTok{)}
\NormalTok{result of }\KeywordTok{yield}\NormalTok{: hello}
\DecValTok{2}
\end{Highlighting}
\end{Shaded}

Its stack frame now contains the local variable \texttt{result}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> gen.gi_frame.f_locals}
\NormalTok{\{}\StringTok{'result'}\NormalTok{: }\StringTok{'hello'}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Other generators created from \texttt{gen\_fn} will have their own stack
frames and their own local variables.

When we call \texttt{send} again, the generator continues from its
second \texttt{yield}, and finishes by raising the special
\texttt{StopIteration} exception:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> gen.send(}\StringTok{'goodbye'}\NormalTok{)}
\NormalTok{result of 2nd }\KeywordTok{yield}\NormalTok{: goodbye}
\NormalTok{Traceback (most recent call last):}
  \NormalTok{File }\StringTok{"<input>"}\NormalTok{, line }\DecValTok{1}\NormalTok{, in <module>}
\OtherTok{StopIteration}\NormalTok{: done}
\end{Highlighting}
\end{Shaded}

The exception has a value, which is the return value of the generator:
the string ``done''.

\aosasecti{Building Coroutines With
Generators}\label{building-coroutines-with-generators}

So a generator can pause, and it can be resumed with a value, and it has
a return value. Sounds like a good primitive upon which to build an
async programming model, without spaghetti callbacks! We want to build a
``coroutine'': a routine that is cooperatively scheduled with other
routines in the program. Our coroutines will be a simplified version of
those in Python's standard ``asyncio'' library. As in asyncio, we will
use generators, futures, and the ``yield from'' statement.

First we need a way to represent some future result that a coroutine is
waiting for. A stripped-down version:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \NormalTok{Future:}
    \KeywordTok{def} \OtherTok{__init__}\NormalTok{(}\OtherTok{self}\NormalTok{):}
        \OtherTok{self}\NormalTok{.result = }\OtherTok{None}
        \OtherTok{self}\NormalTok{._callbacks = []}

    \KeywordTok{def} \NormalTok{add_done_callback(}\OtherTok{self}\NormalTok{, fn):}
        \OtherTok{self}\NormalTok{._callbacks.append(fn)}

    \KeywordTok{def} \NormalTok{set_result(}\OtherTok{self}\NormalTok{, result):}
        \OtherTok{self}\NormalTok{.result = result}
        \KeywordTok{for} \NormalTok{fn in }\OtherTok{self}\NormalTok{._callbacks:}
            \NormalTok{fn(}\OtherTok{self}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A future is initially ``pending''. It is ``resolved'' by a call to
\texttt{set\_result}.\footnote{This future has many deficiencies. For
  example, once this future is resolved, a coroutine that yields it
  should resume immediately instead of pausing, but with our code it
  does not. See asyncio's Future class for a complete implementation.}

Let us adapt our fetcher to use futures and coroutines. Review how we
wrote \texttt{fetch} with a callback:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \NormalTok{Fetcher:}
    \KeywordTok{def} \NormalTok{fetch(}\OtherTok{self}\NormalTok{):}
        \OtherTok{self}\NormalTok{.sock = socket.socket()}
        \OtherTok{self}\NormalTok{.sock.setblocking(}\OtherTok{False}\NormalTok{)}
        \KeywordTok{try}\NormalTok{:}
            \OtherTok{self}\NormalTok{.sock.}\OtherTok{connect}\NormalTok{((}\StringTok{'xkcd.com'}\NormalTok{, }\DecValTok{80}\NormalTok{))}
        \KeywordTok{except} \OtherTok{BlockingIOError}\NormalTok{:}
            \KeywordTok{pass}
        \NormalTok{selector.register(}\OtherTok{self}\NormalTok{.sock.fileno(),}
                          \NormalTok{EVENT_WRITE,}
                          \OtherTok{self}\NormalTok{.connected)}

    \KeywordTok{def} \NormalTok{connected(}\OtherTok{self}\NormalTok{, key, mask):}
        \DataTypeTok{print}\NormalTok{(}\StringTok{'connected!'}\NormalTok{)}
        \CommentTok{# And so on....}
\end{Highlighting}
\end{Shaded}

The \texttt{fetch} method begins connecting a socket, then registers the
callback, \texttt{connected}, to be executed when the socket is ready.
Now we can combine these two steps into one coroutine:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{def} \NormalTok{fetch(}\OtherTok{self}\NormalTok{):}
        \NormalTok{sock = socket.socket()}
        \NormalTok{sock.setblocking(}\OtherTok{False}\NormalTok{)}
        \KeywordTok{try}\NormalTok{:}
            \NormalTok{sock.}\OtherTok{connect}\NormalTok{((}\StringTok{'xkcd.com'}\NormalTok{, }\DecValTok{80}\NormalTok{))}
        \KeywordTok{except} \OtherTok{BlockingIOError}\NormalTok{:}
            \KeywordTok{pass}

        \NormalTok{f = Future()}

        \KeywordTok{def} \NormalTok{on_connected():}
            \NormalTok{f.set_result(}\OtherTok{None}\NormalTok{)}

        \NormalTok{selector.register(sock.fileno(),}
                          \NormalTok{EVENT_WRITE,}
                          \NormalTok{on_connected)}
        \KeywordTok{yield} \NormalTok{f}
        \NormalTok{selector.unregister(sock.fileno())}
        \DataTypeTok{print}\NormalTok{(}\StringTok{'connected!'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now \texttt{fetch} is a generator function, rather than a regular one,
because it contains a \texttt{yield} statement. We create a pending
future, then yield it to pause \texttt{fetch} until the socket is ready.
The inner function \texttt{on\_connected} resolves the future.

But when the future resolves, what resumes the generator? We need a
coroutine \emph{driver}. Let us call it ``task'':

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \NormalTok{Task:}
    \KeywordTok{def} \OtherTok{__init__}\NormalTok{(}\OtherTok{self}\NormalTok{, coro):}
        \OtherTok{self}\NormalTok{.coro = coro}
        \NormalTok{f = Future()}
        \NormalTok{f.set_result(}\OtherTok{None}\NormalTok{)}
        \OtherTok{self}\NormalTok{.step(f)}

    \KeywordTok{def} \NormalTok{step(}\OtherTok{self}\NormalTok{, future):}
        \KeywordTok{try}\NormalTok{:}
            \NormalTok{next_future = }\OtherTok{self}\NormalTok{.coro.send(future.result)}
        \KeywordTok{except} \OtherTok{StopIteration}\NormalTok{:}
            \KeywordTok{return}

        \NormalTok{next_future.add_done_callback(}\OtherTok{self}\NormalTok{.step)}

\CommentTok{# Begin fetching http://xkcd.com/353/}
\NormalTok{fetcher = Fetcher(}\StringTok{'/353/'}\NormalTok{)}
\NormalTok{Task(fetcher.fetch())}

\NormalTok{loop()}
\end{Highlighting}
\end{Shaded}

The task starts the \texttt{fetch} generator by sending \texttt{None}
into it. Then \texttt{fetch} runs until it yields a future, which the
task captures as \texttt{next\_future}. When the socket is connected,
the event loop runs the callback \texttt{on\_connected}, which resolves
the future, which calls \texttt{step}, which resumes \texttt{fetch}.

\aosasecti{Factoring Coroutines With
\texttt{yield from}}\label{factoring-coroutines-with-yield-from}

Once the socket is connected, we send the HTTP GET request and read the
server response. These steps need no longer be scattered among
callbacks; we gather them into the same generator function:

\begin{Shaded}
\begin{Highlighting}[]
    \KeywordTok{def} \NormalTok{fetch(}\OtherTok{self}\NormalTok{):}
        \CommentTok{# ... connection logic from above, then:}
        \NormalTok{sock.send(request.encode(}\StringTok{'ascii'}\NormalTok{))}

        \KeywordTok{while} \OtherTok{True}\NormalTok{:}
            \NormalTok{f = Future()}

            \KeywordTok{def} \NormalTok{on_readable():}
                \NormalTok{f.set_result(sock.recv(}\DecValTok{4096}\NormalTok{))}

            \NormalTok{selector.register(sock.fileno(),}
                              \NormalTok{EVENT_READ,}
                              \NormalTok{on_readable)}
            \NormalTok{chunk = }\KeywordTok{yield} \NormalTok{f}
            \NormalTok{selector.unregister(sock.fileno())}
            \KeywordTok{if} \NormalTok{chunk:}
                \OtherTok{self}\NormalTok{.response += chunk}
            \KeywordTok{else}\NormalTok{:}
                \CommentTok{# Done reading.}
                \KeywordTok{break}
\end{Highlighting}
\end{Shaded}

This code, which reads a whole message from a socket, seems generally
useful. How can we factor it from \texttt{fetch} into a subroutine? Now
Python 3's celebrated \texttt{yield from} takes the stage. It lets one
generator \emph{delegate} to another.

To see how, let us return to our simple generator example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> }\KeywordTok{def} \NormalTok{gen_fn():}
\NormalTok{...     result = }\KeywordTok{yield} \DecValTok{1}
\NormalTok{...     }\DataTypeTok{print}\NormalTok{(}\StringTok{'result of yield: \{\}'}\NormalTok{.}\DataTypeTok{format}\NormalTok{(result))}
\NormalTok{...     result2 = }\KeywordTok{yield} \DecValTok{2}
\NormalTok{...     }\DataTypeTok{print}\NormalTok{(}\StringTok{'result of 2nd yield: \{\}'}\NormalTok{.}\DataTypeTok{format}\NormalTok{(result2))}
\NormalTok{...     }\KeywordTok{return} \StringTok{'done'}
\NormalTok{...     }
\end{Highlighting}
\end{Shaded}

To call this generator from another generator, delegate to it with
\texttt{yield from}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> }\CommentTok{# Generator function:}
\NormalTok{>>> }\KeywordTok{def} \NormalTok{caller_fn():}
\NormalTok{...     gen = gen_fn()}
\NormalTok{...     rv = }\KeywordTok{yield} \CharTok{from} \NormalTok{gen}
\NormalTok{...     }\DataTypeTok{print}\NormalTok{(}\StringTok{'return value of yield-from: \{\}'}
\NormalTok{...           .}\DataTypeTok{format}\NormalTok{(rv))}
\NormalTok{...}
\NormalTok{>>> }\CommentTok{# Make a generator from the}
\NormalTok{>>> }\CommentTok{# generator function.}
\NormalTok{>>> caller = caller_fn()}
\end{Highlighting}
\end{Shaded}

The \texttt{caller} generator acts as if it were \texttt{gen}, the
generator it is delegating to:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> caller.send(}\OtherTok{None}\NormalTok{)}
\DecValTok{1}
\NormalTok{>>> caller.gi_frame.f_lasti}
\DecValTok{15}
\NormalTok{>>> caller.send(}\StringTok{'hello'}\NormalTok{)}
\NormalTok{result of }\KeywordTok{yield}\NormalTok{: hello}
\DecValTok{2}
\NormalTok{>>> caller.gi_frame.f_lasti  }\CommentTok{# Hasn't advanced.}
\DecValTok{15}
\NormalTok{>>> caller.send(}\StringTok{'goodbye'}\NormalTok{)}
\NormalTok{result of 2nd }\KeywordTok{yield}\NormalTok{: goodbye}
\KeywordTok{return} \NormalTok{value of }\KeywordTok{yield}\NormalTok{-}\CharTok{from}\NormalTok{: done}
\NormalTok{Traceback (most recent call last):}
  \NormalTok{File }\StringTok{"<input>"}\NormalTok{, line }\DecValTok{1}\NormalTok{, in <module>}
\OtherTok{StopIteration}
\end{Highlighting}
\end{Shaded}

While \texttt{caller} yields from \texttt{gen}, \texttt{caller} does not
advance. Notice that its instruction pointer remains at 15, the site of
its \texttt{yield from} statement, even while the inner generator
\texttt{gen} advances from one \texttt{yield} statement to the
next.\footnote{In fact, this is exactly how ``yield from'' works in
  CPython. A function increments its instruction pointer before
  executing each statement. But after the outer generator executes
  ``yield from'', it subtracts 1 from its instruction pointer to keep
  itself pinned at the ``yield from'' statement. Then it yields to
  \emph{its} caller. The cycle repeats until the inner generator throws
  \texttt{StopIteration}, at which point the outer generator finally
  allows itself to advance to the next instruction.} From our
perspective outside \texttt{caller}, we cannot tell if the values it
yields are from \texttt{caller} or from the generator it delegates to.
And from inside \texttt{gen}, we cannot tell if values are sent in from
\texttt{caller} or from outside it. The \texttt{yield from} statement is
a frictionless channel, through which values flow in and out of
\texttt{gen} until it \texttt{gen} completes.

A coroutine can delegate work to a sub-coroutine with
\texttt{yield from} and receive the result of the work. Notice, above,
that \texttt{caller} printed ``return value of yield-from: done''. When
\texttt{gen} completed, its return value became the value of the
\texttt{yield from} statement in \texttt{caller}:

\begin{Shaded}
\begin{Highlighting}[]
    \NormalTok{rv = }\KeywordTok{yield} \CharTok{from} \NormalTok{gen}
\end{Highlighting}
\end{Shaded}

Earlier, when we criticized callback-based async programming, our most
strident complaint was about ``stack ripping'': when a callback throws
an exception, the stack trace is typically useless. It only shows that
the event loop was running the callback, not \emph{why}. How do
coroutines fare?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> }\KeywordTok{def} \NormalTok{gen_fn():}
\NormalTok{...     }\KeywordTok{raise} \OtherTok{Exception}\NormalTok{(}\StringTok{'my error'}\NormalTok{)}
\NormalTok{>>> caller = caller_fn()}
\NormalTok{>>> caller.send(}\OtherTok{None}\NormalTok{)}
\NormalTok{Traceback (most recent call last):}
  \NormalTok{File }\StringTok{"<input>"}\NormalTok{, line }\DecValTok{1}\NormalTok{, in <module>}
  \NormalTok{File }\StringTok{"<input>"}\NormalTok{, line }\DecValTok{3}\NormalTok{, in caller_fn}
  \NormalTok{File }\StringTok{"<input>"}\NormalTok{, line }\DecValTok{2}\NormalTok{, in gen_fn}
\OtherTok{Exception}\NormalTok{: my error}
\end{Highlighting}
\end{Shaded}

This is much more useful! The stack trace shows \texttt{caller\_fn} was
delegating to \texttt{gen\_fn} when it threw the error. Even more
comforting, we can wrap the call to a sub-coroutine in an exception
handler, the same is with normal subroutines:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> }\KeywordTok{def} \NormalTok{gen_fn():}
\NormalTok{...     }\KeywordTok{yield} \DecValTok{1}
\NormalTok{...     }\KeywordTok{raise} \OtherTok{Exception}\NormalTok{(}\StringTok{'uh oh'}\NormalTok{)}
\NormalTok{...}
\NormalTok{>>> }\KeywordTok{def} \NormalTok{caller_fn():}
\NormalTok{...     }\KeywordTok{try}\NormalTok{:}
\NormalTok{...         }\KeywordTok{yield} \CharTok{from} \NormalTok{gen_fn()}
\NormalTok{...     }\KeywordTok{except} \OtherTok{Exception} \CharTok{as} \NormalTok{exc:}
\NormalTok{...         }\DataTypeTok{print}\NormalTok{(}\StringTok{'caught \{\}'}\NormalTok{.}\DataTypeTok{format}\NormalTok{(exc))}
\NormalTok{...}
\NormalTok{>>> caller = caller_fn()}
\NormalTok{>>> caller.send(}\OtherTok{None}\NormalTok{)}
\DecValTok{1}
\NormalTok{>>> caller.send(}\StringTok{'hello'}\NormalTok{)}
\NormalTok{caught uh oh}
\end{Highlighting}
\end{Shaded}

So we factor logic with sub-coroutines just like with regular
subroutines. Let us factor some useful sub-coroutines from our fetcher.
We write a \texttt{read} coroutine to receive one chunk:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \NormalTok{read(sock):}
    \NormalTok{f = Future()}

    \KeywordTok{def} \NormalTok{on_readable():}
        \NormalTok{f.set_result(sock.recv(}\DecValTok{4096}\NormalTok{))}

    \NormalTok{selector.register(sock.fileno(), EVENT_READ, on_readable)}
    \NormalTok{chunk = }\KeywordTok{yield} \NormalTok{f  }\CommentTok{# Read one chunk.}
    \NormalTok{selector.unregister(sock.fileno())}
    \KeywordTok{return} \NormalTok{chunk}
\end{Highlighting}
\end{Shaded}

We build on \texttt{read} with a \texttt{read\_all} coroutine that
receives a whole message:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \NormalTok{read_all(sock):}
    \NormalTok{response = []}
    \CommentTok{# Read whole response.}
    \NormalTok{chunk = }\KeywordTok{yield} \CharTok{from} \NormalTok{read(sock)}
    \KeywordTok{while} \NormalTok{chunk:}
        \NormalTok{response.append(chunk)}
        \NormalTok{chunk = }\KeywordTok{yield} \CharTok{from} \NormalTok{read(sock)}

    \KeywordTok{return} \NormalTok{b}\StringTok{''}\NormalTok{.join(response)}
\end{Highlighting}
\end{Shaded}

If you squint the right way, the \texttt{yield from} statements
disappear and these look like conventional functions doing blocking I/O.
But in fact, \texttt{read} and \texttt{read\_all} are coroutines.
Yielding from \texttt{read} pauses \texttt{read\_all} until the I/O
completes. While \texttt{read\_all} is paused, asyncio's event loop does
other work and awaits other I/O events; \texttt{read\_all} is resumed
with the result of \texttt{read} on the next loop tick once its event is
ready.

At the stack's root, \texttt{fetch} calls \texttt{read\_all}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \NormalTok{Fetcher:}
    \KeywordTok{def} \NormalTok{fetch(}\OtherTok{self}\NormalTok{):}
         \CommentTok{# ... connection logic from above, then:}
        \NormalTok{sock.send(request.encode(}\StringTok{'ascii'}\NormalTok{))}
        \OtherTok{self}\NormalTok{.response = }\KeywordTok{yield} \CharTok{from} \NormalTok{read_all(sock)}
\end{Highlighting}
\end{Shaded}

Miraculously, the Task class needs no modification. It drives the outer
\texttt{fetch} coroutine just the same as before:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Task(fetcher.fetch())}
\NormalTok{loop()}
\end{Highlighting}
\end{Shaded}

When \texttt{read} yields a future, the task receives it through the
channel of \texttt{yield from} statements, precisely as if the future
were yielded directly from \texttt{fetch}. When the loop resolves a
future, the task sends its result into \texttt{fetch}, and the value is
received by \texttt{read}, exactly as if the task were driving
\texttt{read} directly:

\aosafigure[240pt]{crawler-images/yield-from.png}{Yield From}{500l.crawler.yieldfrom}

To perfect our coroutine implementation, we polish out one mar: our code
uses \texttt{yield} when it waits for a future, but \texttt{yield from}
when it delegates to a sub-coroutine. It would be more refined if we
used \texttt{yield from} whenever a coroutine pauses. Then a coroutine
need not concern itself with what type of thing it awaits.

We take advantage of the deep correspondence in Python between
generators and iterators. Advancing a generator is, to the caller, the
same as advancing an iterator. So we make our Future class iterable by
implementing a special method:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# Method on Future class.}
    \KeywordTok{def} \OtherTok{__iter__}\NormalTok{(}\OtherTok{self}\NormalTok{):}
        \CommentTok{# Tell Task to resume me here.}
        \KeywordTok{yield} \OtherTok{self}
        \KeywordTok{return} \OtherTok{self}\NormalTok{.result}
\end{Highlighting}
\end{Shaded}

The future's \texttt{\_\_iter\_\_} method is a coroutine that yields the
future itself. Now when we replace code like this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# f is a Future.}
\KeywordTok{yield} \NormalTok{f}
\end{Highlighting}
\end{Shaded}

\ldots{}with this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# f is a Future.}
\KeywordTok{yield} \CharTok{from} \NormalTok{f}
\end{Highlighting}
\end{Shaded}

\ldots{}the outcome is precisely the same! The driving Task receives the
future from its call to \texttt{self.coro.send(result)}, and when the
future is resolved it sends the new result back into the coroutine.

What is the advantage of using \texttt{yield from} everywhere? Why is
that better than waiting for futures with \texttt{yield} and delegating
to sub-coroutines with \texttt{yield from}? It is better because now, a
method can freely change its implementation without affecting the
caller: it might be a normal method that returns a future that will
\emph{resolve} to a value, or it might be a coroutine that contains
\texttt{yield from} statements and \emph{returns} a value. In either
case, the caller need only \texttt{yield from} the method in order to
wait for the result.

Gentle reader, we have reached the end of our enjoyable exposition of
coroutines in asyncio. We peered into the machinery of generators, and
sketched an implementation of futures and tasks. We outlined how asyncio
attains the best of both worlds: concurrent I/O that is more efficient
than threads and more legible than callbacks. Of course, the real
asyncio is much more sophisticated than our sketch. The real framework
addresses zero-copy I/O, fair scheduling, exception handling, and an
abundance of other features.

To an asyncio user, coding with coroutines is much simpler than you saw
here. In the code above we implemented coroutines from first principles,
so you saw callbacks, tasks, and futures. You even saw non-blocking
sockets and the call to \texttt{select}. But when it comes time to build
an application with asyncio, none of this appears in your code. As we
promised, you can fetch a URL as sleekly as this:

\begin{Shaded}
\begin{Highlighting}[]
    \OtherTok{@asyncio.coroutine}
    \KeywordTok{def} \NormalTok{fetch(}\OtherTok{self}\NormalTok{, url):}
        \NormalTok{response = }\KeywordTok{yield} \CharTok{from} \NormalTok{aiohttp.request(}\StringTok{'get'}\NormalTok{, url)}
        \NormalTok{body = }\KeywordTok{yield} \CharTok{from} \NormalTok{response.read()}
\end{Highlighting}
\end{Shaded}

Satisfied with this exposition, we return to our original assignment: to
write an async web crawler, using asyncio.

\aosasecti{Coordinating Coroutines}\label{coordinating-coroutines}

We began by describing how we want our crawler to work. Now it is time
to implement it with asyncio coroutines.

Our crawler will fetch the first page, parse its links, and add them to
a queue. After this it fans out across the website, fetching pages
concurrently. But to limit load on the client and server, we want some
maximum number of workers to run, and no more. Whenever a worker
finishes fetching a page, it should immediately pull the next link from
the queue. We will pass through periods when there is not enough work to
go around, so some workers must pause. But when a worker hits a page
rich with new links, then the queue suddenly grows and any paused
workers should wake and get cracking. Finally, our program must quit
once its work is done.

Imagine if the workers were threads. How would we express the crawler's
algorithm? We could use a synchronized queue\footnote{https://docs.python.org/3/library/queue.html}
from the Python standard library. Each time an item is put in the queue,
the queue increments its count of ``tasks''. Worker threads call
\texttt{task\_done} after completing work on an item. The main thread
blocks on \texttt{Queue.join} until each item put in the queue is
matched by a \texttt{task\_done} call, then it exits.

Coroutines use the exact same pattern with a queue from asyncio! First
we import asyncio's queue\footnote{https://docs.python.org/3/library/asyncio-sync.html}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{try}\NormalTok{:}
    \CharTok{from} \NormalTok{asyncio }\CharTok{import} \NormalTok{JoinableQueue }\CharTok{as} \NormalTok{Queue}
\KeywordTok{except} \OtherTok{ImportError}\NormalTok{:}
    \CommentTok{# In Python 3.5, asyncio.JoinableQueue is}
    \CommentTok{# merged into Queue.}
    \CharTok{from} \NormalTok{asyncio }\CharTok{import} \NormalTok{Queue}
\end{Highlighting}
\end{Shaded}

We collect the workers' shared state in a crawler class, and write the
main logic in its \texttt{crawl} method. We start \texttt{crawl} on a
coroutine and run asyncio's event loop until \texttt{crawl} finishes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{crawler = crawling.Crawler(}\StringTok{'http://xkcd.com'}\NormalTok{,}
                           \NormalTok{max_redirect=}\DecValTok{10}\NormalTok{)}

\NormalTok{loop = asyncio.get_event_loop()}
\NormalTok{loop.run_until_complete(crawler.crawl())}
\end{Highlighting}
\end{Shaded}

The crawler begins with a root URL and \texttt{max\_redirect}, the
number of redirects it is willing to follow to fetch any one URL. It
puts the pair \texttt{(URL, max\_redirect)} in the queue. (For the
reason why, stay tuned.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \NormalTok{Crawler:}
    \KeywordTok{def} \OtherTok{__init__}\NormalTok{(}\OtherTok{self}\NormalTok{, root_url, max_redirect):}
        \OtherTok{self}\NormalTok{.max_tasks = }\DecValTok{10}
        \OtherTok{self}\NormalTok{.max_redirect = max_redirect}
        \OtherTok{self}\NormalTok{.q = Queue()}
        \OtherTok{self}\NormalTok{.seen_urls = }\DataTypeTok{set}\NormalTok{()}
        
        \CommentTok{# Put (URL, max_redirect) in the queue.}
        \OtherTok{self}\NormalTok{.q.put((root_url, }\OtherTok{self}\NormalTok{.max_redirect))}
\end{Highlighting}
\end{Shaded}

The number of unfinished tasks in the queue is now one. Back in our main
script, we launch the event loop and the \texttt{crawl} method:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{loop.run_until_complete(crawler.crawl())}
\end{Highlighting}
\end{Shaded}

The \texttt{crawl} coroutine kicks off the workers. It is like a main
thread: it blocks on \texttt{join} until all tasks are finished, while
the workers run in the background.

\begin{Shaded}
\begin{Highlighting}[]
    \OtherTok{@asyncio.coroutine}
    \KeywordTok{def} \NormalTok{crawl(}\OtherTok{self}\NormalTok{):}
        \CommentTok{"""Run the crawler until all work is done."""}
        \NormalTok{workers = [asyncio.Task(}\OtherTok{self}\NormalTok{.work())}
                   \KeywordTok{for} \NormalTok{_ in }\DataTypeTok{range}\NormalTok{(}\OtherTok{self}\NormalTok{.max_tasks)]}

        \CommentTok{# When all work is done, exit.}
        \KeywordTok{yield} \CharTok{from} \OtherTok{self}\NormalTok{.q.join()}
        \KeywordTok{for} \NormalTok{w in workers:}
            \NormalTok{w.cancel()}
\end{Highlighting}
\end{Shaded}

If the workers were threads we might not wish to start them all at once.
To avoid creating expensive threads until it is certain they are
necessary, a thread pool typically grows on demand. But coroutines are
cheap, so we simply start the maximum number allowed.

It is interesting to note how we shut down the crawler. When the
\texttt{join} future resolves, the worker tasks are alive but suspended:
they wait for more URLs but none come. So, the main coroutine cancels
them before exiting. Otherwise, as the Python interpreter shuts down and
calls all objects' destructors, living tasks cry out:

\begin{verbatim}
ERROR:asyncio:Task was destroyed but it is pending!
\end{verbatim}

And how does \texttt{cancel} work? Generators have a feature we have not
yet shown you. You can throw an exception into a generator from outside:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{>>> gen = gen_fn()}
\NormalTok{>>> gen.send(}\OtherTok{None}\NormalTok{)  }\CommentTok{# Start the generator as usual.}
\DecValTok{1}
\NormalTok{>>> gen.throw(}\OtherTok{Exception}\NormalTok{(}\StringTok{'error'}\NormalTok{))}
\NormalTok{Traceback (most recent call last):}
  \NormalTok{File }\StringTok{"<input>"}\NormalTok{, line }\DecValTok{3}\NormalTok{, in <module>}
  \NormalTok{File }\StringTok{"<input>"}\NormalTok{, line }\DecValTok{2}\NormalTok{, in gen_fn}
\OtherTok{Exception}\NormalTok{: error}
\end{Highlighting}
\end{Shaded}

The generator is resumed by \texttt{throw}, but it is now raising an
exception. If no code in the generator's call stack catches it, the
exception bubbles back up to the top. So to cancel a task's coroutine:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# Method of Task class.}
    \KeywordTok{def} \NormalTok{cancel(}\OtherTok{self}\NormalTok{):}
        \OtherTok{self}\NormalTok{.coro.throw(CancelledError)}
\end{Highlighting}
\end{Shaded}

Wherever the generator is paused, at some \texttt{yield from} statement,
it resumes and throws an exception. We handle cancellation in the task's
\texttt{step} method:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# Method of Task class.}
    \KeywordTok{def} \NormalTok{step(}\OtherTok{self}\NormalTok{, future):}
        \KeywordTok{try}\NormalTok{:}
            \NormalTok{next_future = }\OtherTok{self}\NormalTok{.coro.send(future.result)}
        \KeywordTok{except} \NormalTok{CancelledError:}
            \OtherTok{self}\NormalTok{.cancelled = }\OtherTok{True}
            \KeywordTok{return}
        \KeywordTok{except} \OtherTok{StopIteration}\NormalTok{:}
            \KeywordTok{return}

        \NormalTok{next_future.add_done_callback(}\OtherTok{self}\NormalTok{.step)}
\end{Highlighting}
\end{Shaded}

Now the task knows it is cancelled, so when it is destroyed it does not
rage against the dying of the light.

Once \texttt{crawl} has canceled the workers, it exits. The event loop
sees that the coroutine is complete (we shall see how later), and it too
exits:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{loop.run_until_complete(crawler.crawl())}
\end{Highlighting}
\end{Shaded}

The \texttt{crawl} method comprises all that our main coroutine must do.
It is the worker coroutines that get URLs from the queue, fetch them,
and parse them for new links. Each worker runs the \texttt{work}
coroutine independently:

\begin{Shaded}
\begin{Highlighting}[]
    \OtherTok{@asyncio.coroutine}
    \KeywordTok{def} \NormalTok{work(}\OtherTok{self}\NormalTok{):}
        \KeywordTok{while} \OtherTok{True}\NormalTok{:}
            \NormalTok{url, max_redirect = }\KeywordTok{yield} \CharTok{from} \OtherTok{self}\NormalTok{.q.get()}

            \CommentTok{# Download page and add new links to self.q.}
            \KeywordTok{yield} \CharTok{from} \OtherTok{self}\NormalTok{.fetch(url, max_redirect)}
            \OtherTok{self}\NormalTok{.q.task_done()}
\end{Highlighting}
\end{Shaded}

Python sees that this code contains \texttt{yield from} statements, and
compiles it into a generator function. So in \texttt{crawl}, when the
main coroutine calls \texttt{self.work} ten times, it does not actually
execute this method: it only creates ten generator objects with
references to this code. It wraps each in a Task. The Task receives each
future the generator yields, and drives the generator by calling
\texttt{send} with each future's result when the future resolves.
Because the generators have their own stack frames, they run
independently, with separate local variables and instruction pointers.

The worker coordinates with its fellows via the queue. It waits for new
URLs with:

\begin{Shaded}
\begin{Highlighting}[]
    \NormalTok{url, max_redirect = }\KeywordTok{yield} \CharTok{from} \OtherTok{self}\NormalTok{.q.get()}
\end{Highlighting}
\end{Shaded}

The queue's \texttt{get} method is itself a coroutine: it pauses until
someone puts an item in the queue, then resumes and returns the item.

Incidentally, this is where the worker will be paused at the end of the
crawl, when the main coroutine cancels it. From the coroutine's
perspective, its last trip around the loop ends when \texttt{yield from}
raises a \texttt{CancelledError}.

When a worker fetches a page it parses the links and puts new ones in
the queue, then calls \texttt{task\_done} to decrement the counter.
Eventually, a worker fetches a page whose URLs have all been fetched
already, and there is also no work left in the queue. Thus this worker's
call to \texttt{task\_done} decrements the counter to zero. Then
\texttt{crawl}, which is waiting for the queue's \texttt{join} method,
is unpaused and finishes.

We promised to explain why the items in the queue are pairs, like:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# URL to fetch, and the number of redirects left.}
\NormalTok{(}\StringTok{'http://xkcd.com/353'}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

New URLs have ten redirects remaining. Fetching this particular URL
results in a redirect to a new location with a trailing slash. We
decrement the number of redirects remaining, and put the next location
in the queue:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# URL with a trailing slash. Nine redirects left.}
\NormalTok{(}\StringTok{'http://xkcd.com/353/'}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{aiohttp} package we use would follow redirects by default
and give us the final response. We tell it not to, however, and handle
redirects in the crawler, so it can coalesce redirect paths that lead to
the same destination: if we have already seen this URL, it is in
\texttt{self.seen\_urls} and we have already started on this path from a
different entry point:

\aosafigure[240pt]{crawler-images/redirects.png}{Redirects}{500l.crawler.redirects}

The crawler fetches ``foo'' and sees it redirects to ``baz'', so it adds
``baz'' to the queue and to \texttt{seen\_urls}. If the next page it
fetches is ``bar'', which also redirects to ``baz'', the fetcher does
not enqueue ``baz'' again.

\begin{Shaded}
\begin{Highlighting}[]
    \OtherTok{@asyncio.coroutine}
    \KeywordTok{def} \NormalTok{fetch(}\OtherTok{self}\NormalTok{, url, max_redirect):}
        \CommentTok{# Handle redirects ourselves.}
        \NormalTok{response = }\KeywordTok{yield} \CharTok{from} \NormalTok{aiohttp.request(}
            \StringTok{'get'}\NormalTok{, url, allow_redirects=}\OtherTok{False}\NormalTok{)}

        \KeywordTok{if} \NormalTok{is_redirect(response):}
            \KeywordTok{if} \NormalTok{max_redirect > }\DecValTok{0}\NormalTok{:}
                \NormalTok{next_url = response.headers[}\StringTok{'location'}\NormalTok{]}
                \KeywordTok{if} \NormalTok{next_url in }\OtherTok{self}\NormalTok{.seen_urls:}
                    \CommentTok{# We have been down this path before.}
                    \KeywordTok{return}

                \CommentTok{# Remember we have seen this URL.}
                \OtherTok{self}\NormalTok{.seen_urls.add(next_url)}
                
                \CommentTok{# Follow the redirect. One less redirect remains.}
                \OtherTok{self}\NormalTok{.q.put_nowait((next_url, max_redirect - }\DecValTok{1}\NormalTok{))}
         \KeywordTok{else}\NormalTok{:}
             \NormalTok{links = }\KeywordTok{yield} \CharTok{from} \OtherTok{self}\NormalTok{.parse_links(response)}
             \CommentTok{# Python set-logic:}
             \KeywordTok{for} \NormalTok{link in links.difference(}\OtherTok{self}\NormalTok{.seen_urls):}
                \OtherTok{self}\NormalTok{.q.put_nowait((link, }\OtherTok{self}\NormalTok{.max_redirect))}
            \OtherTok{self}\NormalTok{.seen_urls.update(links)}
\end{Highlighting}
\end{Shaded}

If the response is a page, rather than a redirect, \texttt{fetch} parses
it for links and puts new ones in the queue.

If this were multithreaded code, it would be lousy with race conditions.
For example, in the last few lines the worker checks if a link is in
\texttt{seen\_urls}, and if not the worker puts it in the queue and adds
it to \texttt{seen\_urls}. If it were interrupted between the two
operations, then another worker might parse the same link from a
different page, also observe that it is not in \texttt{seen\_urls}, and
also add it to the queue. Now that same link is in the queue twice,
leading (at best) to duplicated work and wrong statistics.

However, a coroutine is only vulnerable to interruption at
\texttt{yield from} statements. This is a key difference that makes
coroutine code far less prone to races than multithreaded code:
multithreaded code must enter a critical section explicitly, by grabbing
a lock, otherwise it is interruptible. A Python coroutine, however, is
uninterruptible by default, and only cedes control when it explicitly
yields.

We no longer need a fetcher class like we had in the callback-based
program. That class was a workaround for a deficiency of callbacks: they
need some place to store state while waiting for I/O, since their local
variables are not preserved across calls. But the \texttt{fetch}
coroutine can store its state in local variables like a regular function
does, so there is no more need for a class.

When \texttt{fetch} finishes processing the server response it returns
to the caller, \texttt{work}. The \texttt{work} method calls
\texttt{task\_done} on the queue and then gets the next URL from the
queue to be fetched.

When \texttt{fetch} puts new links in the queue it increments the count
of unfinished tasks and keeps the main coroutine, which is waiting for
\texttt{q.join}, paused. If, however, there are no unseen links and this
was the last URL in the queue, then when \texttt{work} calls
\texttt{task\_done} the count of unfinished tasks falls to zero. That
event unpauses \texttt{join} and the main coroutine completes.

The queue code that coordinates the workers and the main coroutine is
like this\footnote{The actual asyncio.Queue implementation uses an
  asyncio.Event in place of the Future shown here. The difference is an
  Event can be reset, whereas a Future cannot transition from resolved
  back to pending.}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \NormalTok{Queue:}
    \KeywordTok{def} \OtherTok{__init__}\NormalTok{(}\OtherTok{self}\NormalTok{):}
        \OtherTok{self}\NormalTok{._join_future = Future()}
        \OtherTok{self}\NormalTok{._unfinished_tasks = }\DecValTok{0}
        \CommentTok{# ... other initialization ...}
    
    \KeywordTok{def} \NormalTok{put_nowait(}\OtherTok{self}\NormalTok{, item):}
        \OtherTok{self}\NormalTok{._unfinished_tasks += }\DecValTok{1}
        \CommentTok{# ... store the item ...}

    \KeywordTok{def} \NormalTok{task_done(}\OtherTok{self}\NormalTok{):}
        \OtherTok{self}\NormalTok{._unfinished_tasks -= }\DecValTok{1}
        \KeywordTok{if} \OtherTok{self}\NormalTok{._unfinished_tasks == }\DecValTok{0}\NormalTok{:}
            \OtherTok{self}\NormalTok{._join_future.set_result(}\OtherTok{None}\NormalTok{)}

    \OtherTok{@asyncio.coroutine}
    \KeywordTok{def} \NormalTok{join(}\OtherTok{self}\NormalTok{):}
        \KeywordTok{if} \OtherTok{self}\NormalTok{._unfinished_tasks > }\DecValTok{0}\NormalTok{:}
            \KeywordTok{yield} \CharTok{from} \OtherTok{self}\NormalTok{._join_future}
\end{Highlighting}
\end{Shaded}

The main coroutine, \texttt{crawl}, yields from \texttt{join}. So when
the last worker decrements the count of unfinished tasks to zero, it
signals \texttt{crawl} to resume, and finish.

The ride is almost over. Our program began with the call to
\texttt{crawl}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{loop.run_until_complete(}\OtherTok{self}\NormalTok{.crawler.crawl())}
\end{Highlighting}
\end{Shaded}

How does the program end? Since \texttt{crawl} is a generator function,
calling it returns a generator. To drive the generator, asyncio wraps it
in a task:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \NormalTok{EventLoop:}
    \KeywordTok{def} \NormalTok{run_until_complete(}\OtherTok{self}\NormalTok{, coro):}
        \CommentTok{"""Run until the coroutine is done."""}
        \NormalTok{task = Task(coro)}
        \NormalTok{task.add_done_callback(stop_callback)}
        \KeywordTok{try}\NormalTok{:}
            \OtherTok{self}\NormalTok{.run_forever()}
        \KeywordTok{except} \NormalTok{StopError:}
            \KeywordTok{pass}

\KeywordTok{class} \NormalTok{StopError(}\OtherTok{BaseException}\NormalTok{):}
    \CommentTok{"""Raised to stop the event loop."""}

\KeywordTok{def} \NormalTok{stop_callback(future):}
    \KeywordTok{raise} \NormalTok{StopError}
\end{Highlighting}
\end{Shaded}

When the task completes, it raises \texttt{StopError}, which the loop
uses as a signal that it has arrived at normal completion.

But what's this? The task has methods called
\texttt{add\_done\_callback} and \texttt{result}? You might think that a
task resembles a future. Your instinct is correct. We must admit a
detail about the Task class we hid from you: a task is a future.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \NormalTok{Task(Future):}
    \CommentTok{"""A coroutine wrapped in a Future."""}
\end{Highlighting}
\end{Shaded}

Normally a future is resolved by someone else calling
\texttt{set\_result} on it. But a task resolves \emph{itself} when its
coroutine stops. Remember from our earlier exploration of Python
generators that when a generator returns, it throws the special
\texttt{StopIteration} exception:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# Method of class Task.}
    \KeywordTok{def} \NormalTok{step(}\OtherTok{self}\NormalTok{, future):}
        \KeywordTok{try}\NormalTok{:}
            \NormalTok{next_future = }\OtherTok{self}\NormalTok{.coro.send(future.result)}
        \KeywordTok{except} \NormalTok{CancelledError:}
            \OtherTok{self}\NormalTok{.cancelled = }\OtherTok{True}
            \KeywordTok{return}
        \KeywordTok{except} \OtherTok{StopIteration} \CharTok{as} \NormalTok{exc:}

            \CommentTok{# Task resolves itself with coro's return}
            \CommentTok{# value.}
            \OtherTok{self}\NormalTok{.set_result(exc.value)}
            \KeywordTok{return}

        \NormalTok{next_future.add_done_callback(}\OtherTok{self}\NormalTok{.step)}
\end{Highlighting}
\end{Shaded}

So when the event loop calls
\texttt{task.add\_done\_callback(stop\_callback)}, it prepares to be
stopped by the task. Here is \texttt{run\_until\_complete} again:

\begin{Shaded}
\begin{Highlighting}[]
    \CommentTok{# Method of event loop.}
    \KeywordTok{def} \NormalTok{run_until_complete(}\OtherTok{self}\NormalTok{, coro):}
        \NormalTok{task = Task(coro)}
        \NormalTok{task.add_done_callback(stop_callback)}
        \KeywordTok{try}\NormalTok{:}
            \OtherTok{self}\NormalTok{.run_forever()}
        \KeywordTok{except} \NormalTok{StopError:}
            \KeywordTok{pass}
\end{Highlighting}
\end{Shaded}

When the task catches \texttt{StopIteration} and resolves itself, the
callback raises \texttt{StopError} from within the loop. The loop stops
and the call stack is unwound to \texttt{run\_until\_complete}. Our
program is finished.

\aosasecti{Conclusion}\label{conclusion}

Increasingly often, modern programs are I/O-bound instead of CPU-bound.
For such programs, Python threads are the worst of both worlds: the
global interpreter lock prevents them from actually executing
computations in parallel, and preemptive switching makes them prone to
races. Async is often the right pattern. But as callback-based async
code grows, it tends to become a dishevelled mess. Coroutines are a tidy
alternative. They factor naturally into subroutines, with sane exception
handling and stack traces.

If we squint so that the \texttt{yield from} statements blur, a
coroutine looks like a thread doing traditional blocking I/O. We can
even coordinate coroutines with classic patterns from multi-threaded
programming. There is no need for reinvention. Thus, compared to
callbacks, coroutines are an inviting idiom to the coder experienced
with multithreading.

But when we open our eyes and focus on the \texttt{yield from}
statements, we see they mark points when the coroutine cedes control and
allows others to run. Unlike threads, coroutines display where our code
can be interrupted and where it cannot. In his illuminating essay
``Unyielding''\footnote{https://glyph.twistedmatrix.com/2014/02/unyielding.html},
Glyph Lefkowitz writes, ``Threads make local reasoning difficult, and
local reasoning is perhaps the most important thing in software
development.'' Explicitly yielding, however, makes it possible to
``understand the behavior (and thereby, the correctness) of a routine by
examining the routine itself rather than examining the entire system.''

Now that you know how asyncio coroutines work, you can largely forget
the details. The machinery is tucked behind a dapper interface. But
understanding the fundamentals empowers you to code correctly and
efficiently in modern async environments.

\end{aosachapter}
