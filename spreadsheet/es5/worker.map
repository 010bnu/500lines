{"version":3,"sources":["../worker.js","@traceur/generated/TemplateParser/4","@traceur/generated/TemplateParser/5","@traceur/generated/TemplateParser/3","@traceur/generated/TemplateParser/0","@traceur/generated/TemplateParser/1","@traceur/generated/TemplateParser/2"],"names":[],"mappings":"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","sourcesContent":["if (self.importScripts) {\n  let sheet, errs, vals;\n  self.onmessage = ({data})=>{\n    [sheet, errs, vals] = [ data, {}, {} ];\n\n    for (const coord in sheet) {\n      // Four variable names pointing to the same coordinate: A1, a1, $A1, $a1\n      for (const name of [ for (p of [ '', '$' ])\n                             for (c of [ coord, coord.toLowerCase() ])\n                               p+c ]) {\n        // Worker is reused across computations, so only define each variable once\n        if ((Object.getOwnPropertyDescriptor( self, name ) || {}).get) { continue; }\n\n        // Define self['A1'], which is the same thing as the global variable A1\n        Object.defineProperty( self, name, { get() {\n          if (coord in vals) { return vals[coord]; }\n          vals[coord] = NaN;\n\n          // Turn numeric strings into numbers, so =A1+C1 works when both are numbers\n          let x = +sheet[coord];\n          if (sheet[coord] !== x.toString()) { x = sheet[coord]; }\n\n          // Evaluate formula cells that begin with =\n          try { vals[coord] = (('=' === x[0]) ? eval.call( null, x.slice( 1 ) ) : x);\n          } catch (e) {\n            const match = /\\$?[A-Za-z]+[1-9][0-9]*\\b/.exec( e );\n            if (match && !( match[0] in self )) {\n              // The formula refers to a uninitialized cell; set it to 0 and retry\n              self[match[0]] = 0;\n              delete vals[coord];\n              return self[coord];\n            }\n            // Otherwise, stringify the caught exception in the errs object\n            errs[coord] = e.toString();\n          }\n          return((typeof vals[coord] === 'number') ? vals[coord] : vals[coord] += '');\n        } } )\n      }\n    }\n\n    // For each coordinate in the sheet, call the property getter defined above\n    for (const coord in sheet) { self[coord]; }\n    postMessage([ errs, vals ]);\n  }\n}\n","$traceurRuntime.assertObject($__placeholder__0)","$__placeholder__0 = $__placeholder__1","\n        for (var $__placeholder__0 =\n                 $__placeholder__1[Symbol.iterator](),\n                 $__placeholder__2;\n             !($__placeholder__3 = $__placeholder__4.next()).done; ) {\n          $__placeholder__5;\n          $__placeholder__6;\n        }","var $__placeholder__0 = 0, $__placeholder__1 = [];","$__placeholder__0[$__placeholder__1++] = $__placeholder__2;","return $__placeholder__0;"]}
